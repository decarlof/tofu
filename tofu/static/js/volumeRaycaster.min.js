function buildAxes(length){var axes=new THREE.Object3D;return axes.add(buildAxis(new THREE.Vector3(0,0,-.5),new THREE.Vector3(length,0,-.5),16711680,!1)),axes.add(buildAxis(new THREE.Vector3(0,0,0),new THREE.Vector3(0,0,length),255,!1)),axes.add(buildAxis(new THREE.Vector3(0,0,0),new THREE.Vector3(0,0,-length),255,!0)),axes}function buildAxis(src,dst,colorHex,dashed){var mat,geom=new THREE.Geometry;mat=dashed?new THREE.LineDashedMaterial({linewidth:1,color:colorHex,dashSize:3,gapSize:3}):new THREE.LineBasicMaterial({linewidth:1,color:colorHex}),geom.vertices.push(src.clone()),geom.vertices.push(dst.clone()),geom.computeLineDistances();var axis=new THREE.Line(geom,mat,THREE.LinePieces);return axis}!function(namespace){namespace.VRC={}}(window),function(namespace){var EventDispatcher=function(O){var me={};return me["class"]=this,me._functions=[],me._context=window,me.add=function(func,is_start){return me._functions.push({is_start:void 0!=is_start?is_start:!0,func:func}),me._functions.length-1},me.remove=function(index){delete me._functions[index]},me.get=function(index){return me._functions[index]},me.stop=function(index){me._functions[index].is_start=!1},me.start=function(index){me._functions[index].is_start=!0},me.isStart=function(index){return me._functions[index].is_start},me.call=function(value,context){var context=context?context:me._context;for(i in me._functions){var task=me._functions[i];task.is_start&&task.func.call(context,value)}},me.isEmpty=function(){return 0==me._functions.length},me.setConfig=function(O){for(prop in O)switch(prop){case"context":this._context=O[prop]}},me.Constructor=function(O){this.setConfig(O)},me.Constructor(O),me};namespace.EventDispatcher=EventDispatcher}(window.VRC),function(namespace){var AdaptationManager=function(){var me={};return me._core={},me._step=5,me._steps=2*me._step,me._onPostDrawFuncIndex=-1,me._onCameraChangeStartFuncIndex=-1,me._onCameraChangeEndFuncIndex=-1,me.init=function(core){me._core=core,me._onPostDrawFuncIndex=me._core.onPostDraw.add(function(fps){me["do"](fps)}),me._onCameraChangeStartFuncIndex=me._core.onCameraChangeStart.add(function(){}),me._onCameraChangeEndFuncIndex=me._core.onCameraChangeEnd.add(function(){})},me.run=function(flag){flag?(me._core.onPostDraw.start(me._onPostDrawFuncIndex),me._core.onCameraChangeStart.start(me._onCameraChangeEndFuncIndex),me._core.onCameraChangeEnd.start(me._onCameraChangeStartFuncIndex)):(me._core.onPostDraw.stop(me._onPostDrawFuncIndex),me._core.onCameraChangeStart.stop(me._onCameraChangeEndFuncIndex),me._core.onCameraChangeEnd.stop(me._onCameraChangeStartFuncIndex))},me.pause=function(flag){flag?(me._core.onCameraChangeStart.stop(me._onCameraChangeEndFuncIndex),me._core.onPostDraw.stop(me._onPostDrawFuncIndex)):(me._core.onCameraChangeStart.start(me._onCameraChangeEndFuncIndex),me._core.onPostDraw.start(me._onPostDrawFuncIndex))},me.getNearestSurroundingsPossibleStep=function(steps){for(var delta=me._step,direction=me._step*(steps-me.getSteps())>0?1:-1,adaptationSteps=me.getSteps();adaptationSteps<me._core.getMaxStepsNumber();adaptationSteps+=direction)if(Math.abs(adaptationSteps-steps)<=delta){if(steps>adaptationSteps)return[adaptationSteps,adaptationSteps+me._step];if(steps>adaptationSteps)return[adaptationSteps-me._step,adaptationSteps];if(steps==adaptationSteps)return[adaptationSteps-me._step,adaptationSteps+me._step]}return[me._core.getMaxStepsNumber()-me._step,me._core.getMaxStepsNumber()]},me.decreaseSteps=function(){var nearestSurroundingsPossibleSteps=me.getNearestSurroundingsPossibleStep(me._core.getSteps());me._steps=nearestSurroundingsPossibleSteps[0]},me.increaseSteps=function(){var nearestSurroundingsPossibleSteps=me.getNearestSurroundingsPossibleStep(me._core.getSteps());me._steps=nearestSurroundingsPossibleSteps[1]},me.getSteps=function(){return me._steps},me.isRun=function(){var isRunOnPostDraw=me._core.onPostDraw.isStart(me._onPostDrawFuncIndex),isRunOnCameraChangeStart=me._core.onCameraChangeStart.isStart(me._onCameraChangeEndFuncIndex),isRunOnCameraChangeEnd=me._core.onCameraChangeEnd.isStart(me._onCameraChangeStartFuncIndex);return isRunOnPostDraw&&isRunOnCameraChangeStart&&isRunOnCameraChangeEnd},me.isPause=function(){var isRunOnPostDraw=me._core.onPostDraw.isStart(me._onPostDrawFuncIndex),isRunOnCameraChangeStart=me._core.onCameraChangeStart.isStart(me._onCameraChangeEndFuncIndex),isRunOnCameraChangeEnd=me._core.onCameraChangeEnd.isStart(me._onCameraChangeStartFuncIndex);return!isRunOnPostDraw&&!isRunOnCameraChangeStart&&isRunOnCameraChangeEnd},me._numberOfChanges=0,me["do"]=function(fps){10>fps&&me.getSteps()>2*me._step?(me._numberOfChanges--,-5==me._numberOfChanges&&(me.decreaseSteps(),me._numberOfChanges=0,me._core.setSteps(me.getSteps()))):fps>30&&me.getSteps()<me._core.getMaxStepsNumber()&&(me._numberOfChanges++,3==me._numberOfChanges&&(me.increaseSteps(),me._numberOfChanges=0,me._core.setSteps(me.getSteps())))},me};namespace.AdaptationManager=AdaptationManager}(window.VRC),function(namespace){var GeometryHelper=function(){var me={};return me.createBoxGeometry=function(geometryDimension,volumeSize,zFactor){for(var vertexPositions=[[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmax*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymin*volumeSize[1],geometryDimension.zmin*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmax*volumeSize[2]],[geometryDimension.xmin*volumeSize[0],geometryDimension.ymax*volumeSize[1],geometryDimension.zmin*volumeSize[2]]],vertexColors=[[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmin],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmin],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmin],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmax,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmax,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymin,geometryDimension.zmin],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmax],[geometryDimension.xmin,geometryDimension.ymax,geometryDimension.zmin]],positions=[],colors=[],i=0;i<vertexPositions.length;i++){var backCounter=vertexPositions.length-1-i,x=vertexPositions[backCounter][0],y=vertexPositions[backCounter][1],z=vertexPositions[backCounter][2]*zFactor,r=vertexColors[backCounter][0],g=vertexColors[backCounter][1],b=vertexColors[backCounter][2];positions.push(x),positions.push(y),positions.push(z),colors.push(r),colors.push(g),colors.push(b),colors.push(1)}var geometry=new THREE.BufferGeometry,bufferPositions=new Float32Array(positions);return geometry.addAttribute("position",new THREE.BufferAttribute(bufferPositions,3)),geometry.addAttribute("vertColor",new THREE.BufferAttribute(new Float32Array(colors),4)),geometry.computeBoundingSphere(),geometry},me};namespace.GeometryHelper=GeometryHelper}(window.VRC);var Core=function(conf){this.zFactor=void 0!=conf.zFactor?conf.zFactor:1,this.l=conf.l,this.s=conf.s,this.hMin=conf.hMin,this.hMax=conf.hMax,this.minRefl=conf.minRefl,this.minSos=conf.minSos,this.minAtten=conf.minAtten,this.maxRefl=conf.maxRefl,this.maxSos=conf.maxSos,this.maxAtten=conf.maxAtten,this._steps=20,this._slices_gap=[0,"*"],this._slicemap_row_col=[16,16],this._gray_value=[0,1],this._slicemaps_images=[],this._slicemaps_paths=[],this._slicemaps_textures=[],this._opacity_factor=void 0!=conf.opacity_factor?conf.opacity_factor:35,this._color_factor=void 0!=conf.color_factor?conf.color_factor:3,this._shader_name=void 0==conf.shader_name?"secondPass":conf.shader_name,this._render_size=void 0==conf.renderer_size?["*","*"]:conf.renderer_size,this._canvas_size=conf.renderer_canvas_size,this._render_clear_color="#000",this._transfer_function_as_image=new Image,this._volume_sizes=[1024,1024,1024],this._geometry_dimensions={xmin:0,xmax:1,ymin:0,ymax:1,zmin:0,zmax:1},this._threshold_otsu_index=0,this._threshold_isodata_index=0,this._threshold_yen_index=0,this._threshold_li_index=0,this._transfer_function_colors=[{pos:.25,color:"#892c2c"},{pos:.5,color:"#00ff00"},{pos:.75,color:"#0000ff"}],this._dom_container_id=void 0!=conf.domContainerId?conf.domContainerId:"container",this._dom_container={},this._render={},this._camera={},this._camera_settings={rotation:{x:0,y:0,z:0},position:{x:0,y:0,z:2}},this._rtTexture={},this._geometry={},this._geometry_settings={rotation:{x:0,y:0,z:0}},this._materialFirstPass={},this._materialSecondPass={},this._sceneFirstPass={},this._sceneSecondPass={},this._meshFirstPass={},this._meshSecondPass={},this.onPreDraw=new VRC.EventDispatcher,this.onPostDraw=new VRC.EventDispatcher,this.onResizeWindow=new VRC.EventDispatcher,this.onCameraChange=new VRC.EventDispatcher,this.onCameraChangeStart=new VRC.EventDispatcher,this.onCameraChangeEnd=new VRC.EventDispatcher,this.onChangeTransferFunction=new VRC.EventDispatcher,this._onWindowResizeFuncIndex_canvasSize=-1,this._onWindowResizeFuncIndex_renderSize=-1,this._callback=conf.callback;try{this._canvas_size[0]>this._canvas_size[1]&&(this._camera_settings.position.z=2)}catch(e){}};Core.prototype.init=function(){var me=this;this._container=this.getDOMContainer(),this._render=new THREE.WebGLRenderer({alpha:!0}),this._render.setSize(this.getRenderSizeInPixels()[0],this.getRenderSizeInPixels()[1]),this._render.setClearColor(this._render_clear_color,0),this._container.appendChild(this._render.domElement),this._camera=new THREE.PerspectiveCamera(45,this.getRenderSizeInPixels()[0]/this.getRenderSizeInPixels()[1],.01,11),this._camera.position.x=this._camera_settings.position.x,this._camera.position.y=this._camera_settings.position.y,this._camera.position.z=this._camera_settings.position.z,this._camera.rotation.x=this._camera_settings.rotation.x,this._camera.rotation.y=this._camera_settings.rotation.y,this._camera.rotation.z=this._camera_settings.rotation.z,this.isAxisOn=!1,this._controls=new THREE.TrackballControls(this._camera,this._render.domElement),this._controls.rotateSpeed=50,this._controls.zoomSpeed=3,this._controls.panSpeed=12,this._controls.noZoom=!1,this._controls.noPan=!1,this._controls.staticMoving=!0,this._controls.dynamicDampingFactor=.3,this._rtTexture=new THREE.WebGLRenderTarget(this.getRenderSizeInPixels()[0],this.getRenderSizeInPixels()[1],{minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat}),this._rtTexture.wrapS=this._rtTexture.wrapT=THREE.ClampToEdgeWrapping,this._materialFirstPass=new THREE.ShaderMaterial({vertexShader:this._shaders.firstPass.vertexShader,fragmentShader:this._shaders.firstPass.fragmentShader,attributes:{vertColor:{type:"c",value:[]}},side:THREE.FrontSide,transparent:!0}),this._materialSecondPass=new THREE.ShaderMaterial({vertexShader:this._shaders[this._shader_name].vertexShader,fragmentShader:ejs.render(this._shaders[this._shader_name].fragmentShader,{maxTexturesNumber:me.getMaxTexturesNumber()}),attributes:{vertColor:{type:"c",value:[]}},uniforms:{uBackCoord:{type:"t",value:this._rtTexture},uSliceMaps:{type:"tv",value:this._slicemaps_textures},uSteps:{type:"f",value:this._steps},uNumberOfSlices:{type:"f",value:this.getSlicesRange()[1]},uSlicesOverX:{type:"f",value:this._slicemap_row_col[0]},uSlicesOverY:{type:"f",value:this._slicemap_row_col[1]},uOpacityVal:{type:"f",value:this._opacity_factor},darkness:{type:"f",value:this._color_factor},l:{type:"f",value:this.l},s:{type:"f",value:this.s},hMin:{type:"f",value:this.hMin},hMax:{type:"f",value:this.hMax},minSos:{type:"f",value:this.minSos},maxSos:{type:"f",value:this.maxSos},minAtten:{type:"f",value:this.minAtten},maxAtten:{type:"f",value:this.maxAtten},minRefl:{type:"f",value:this.minRefl},maxRefl:{type:"f",value:this.maxRefl},uTransferFunction:{type:"t",value:this._transfer_function},uColorVal:{type:"f",value:this._color_factor},uAbsorptionModeIndex:{type:"f",value:this._absorption_mode_index},uMinGrayVal:{type:"f",value:this._gray_value[0]},uMaxGrayVal:{type:"f",value:this._gray_value[1]}},side:THREE.BackSide,transparent:!0}),this._sceneFirstPass=new THREE.Scene,this._sceneSecondPass=new THREE.Scene,this._initGeometry(this.getGeometryDimensions(),this.getVolumeSizeNormalized()),this._meshFirstPass=new THREE.Mesh(this._geometry,this._materialFirstPass),this._meshSecondPass=new THREE.Mesh(this._geometry,this._materialSecondPass),this._axes=buildAxes(.5),this._sceneFirstPass.add(this._meshFirstPass),this._sceneSecondPass.add(this._meshSecondPass),window.addEventListener("resize",function(){me.onResizeWindow.call()},!1),this._controls.addEventListener("change",function(){console.log("Controls Changes"),me.onCameraChange.call()}),this._controls.addEventListener("start",function(){console.log("Controls Starts"),me.onCameraChangeStart.call()}),this._controls.addEventListener("end",function(){console.log("Controls End"),me.onCameraChangeEnd.call()}),this._onWindowResizeFuncIndex_canvasSize=this.onResizeWindow.add(function(){me.setRenderCanvasSize("*","*")},!1),this.setTransferFunctionByColors(this._transfer_function_colors),this._render.setSize(this.getRenderSizeInPixels()[0],this.getRenderSizeInPixels()[1]),this.setRenderCanvasSize(this.getCanvasSize()[0],this.getCanvasSize()[1]);try{this._callback()}catch(e){}},Core.prototype._secondPassSetUniformValue=function(key,value){this._materialSecondPass.uniforms[key].value=value},Core.prototype._setSlicemapsTextures=function(images){for(var textures=[],i=0;i<images.length;i++){var texture=new THREE.Texture(images[i]);texture.magFilter=THREE.LinearFilter,texture.minFilter=THREE.LinearFilter,texture.wrapS=texture.wrapT=THREE.ClampToEdgeWrapping,texture.generateMipmaps=!1,texture.flipY=!1,texture.needsUpdate=!0,textures.push(texture)}this._slicemaps_textures=textures},Core.prototype.setTransferFunctionByImage=function(image){console.log("Core: setTransferFunctionByImage()"),this._transfer_function_as_image=image;var texture=new THREE.Texture(image);texture.magFilter=THREE.LinearFilter,texture.minFilter=THREE.LinearFilter,texture.wrapS=texture.wrapT=THREE.ClampToEdgeWrapping,texture.generateMipmaps=!1,texture.flipY=!0,texture.needsUpdate=!0,this._secondPassSetUniformValue("uTransferFunction",texture),this.onChangeTransferFunction.call(image)},Core.prototype.setL=function(v){this.l=v,this._secondPassSetUniformValue("l",this.l)},Core.prototype.setS=function(v){this.s=v,this._secondPassSetUniformValue("s",this.s)},Core.prototype.setHMin=function(v){this.hMin=v,this._secondPassSetUniformValue("hMin",this.hMin)},Core.prototype.setHMax=function(v){this.hMax=v,this._secondPassSetUniformValue("hMax",this.hMax)},Core.prototype.setMaxRefl=function(v){this.maxRefl=v,this._secondPassSetUniformValue("maxRefl",this.maxRefl)},Core.prototype.setMaxSos=function(v){this.maxSos=v,this._secondPassSetUniformValue("maxSos",this.maxSos)},Core.prototype.setMinAtten=function(v){this.minAtten=v,this._secondPassSetUniformValue("minAtten",this.minAtten)},Core.prototype.setMinRefl=function(v){this.minRefl=v,this._secondPassSetUniformValue("minRefl",this.minRefl)},Core.prototype.setMinSos=function(v){this.minSos=v,this._secondPassSetUniformValue("minSos",this.minSos)},Core.prototype.setMaxAtten=function(v){this.maxAtten=v,this._secondPassSetUniformValue("maxAtten",this.maxAtten)},Core.prototype.setTransferFunctionByColors=function(colors){console.log("Core: setTransferFunctionByColors()"),this._transfer_function_colors=colors;var canvas=document.createElement("canvas");canvas.width=512,canvas.height=2;for(var ctx=canvas.getContext("2d"),grd=ctx.createLinearGradient(0,0,canvas.width-1,canvas.height-1),i=0;i<colors.length;i++)grd.addColorStop(colors[i].pos,colors[i].color);ctx.fillStyle=grd,ctx.fillRect(0,0,canvas.width,canvas.height);var image=new Image;image.src=canvas.toDataURL(),image.style.width="20 px",image.style.height="512 px";this.setTransferFunctionByImage(image);this.onChangeTransferFunction.call(image)},Core.prototype.getTransferFunctionAsImage=function(){return this._transfer_function_as_image},Core.prototype._initGeometry=function(geometryDimensions,volumeSizes){var geometryHelper=new VRC.GeometryHelper;this._geometry=geometryHelper.createBoxGeometry(geometryDimensions,volumeSizes,this.zFactor),this._geometry.applyMatrix((new THREE.Matrix4).makeTranslation(-volumeSizes[0]/2,-volumeSizes[1]/2,-volumeSizes[2]/2)),this._geometry.applyMatrix((new THREE.Matrix4).makeRotationX(this._geometry_settings.rotation.x)),this._geometry.applyMatrix((new THREE.Matrix4).makeRotationY(this._geometry_settings.rotation.y)),this._geometry.applyMatrix((new THREE.Matrix4).makeRotationZ(this._geometry_settings.rotation.z)),this._geometry.doubleSided=!0},Core.prototype.setMode=function(conf){this._shader_name=conf.shader_name,this._materialSecondPass=new THREE.ShaderMaterial({vertexShader:this._shaders[this._shader_name].vertexShader,fragmentShader:ejs.render(this._shaders[this._shader_name].fragmentShader,{maxTexturesNumber:this.getMaxTexturesNumber()}),attributes:{vertColor:{type:"c",value:[]}},uniforms:{uBackCoord:{type:"t",value:this._rtTexture},uSliceMaps:{type:"tv",value:this._slicemaps_textures},uNumberOfSlices:{type:"f",value:this.getSlicesRange()[1]},uSlicesOverX:{type:"f",value:this._slicemap_row_col[0]},uSlicesOverY:{type:"f",value:this._slicemap_row_col[1]},uOpacityVal:{type:"f",value:this._opacity_factor},darkness:{type:"f",value:this._color_factor},l:{type:"f",value:this.l},s:{type:"f",value:this.s},hMin:{type:"f",value:this.hMin},hMax:{type:"f",value:this.hMax},minSos:{type:"f",value:this.minSos},maxSos:{type:"f",value:this.maxSos},minAtten:{type:"f",value:this.minAtten},maxAtten:{type:"f",value:this.maxAtten},minRefl:{type:"f",value:this.minRefl},maxRefl:{type:"f",value:this.maxRefl}},side:THREE.BackSide,transparent:!0}),this._meshSecondPass=new THREE.Mesh(this._geometry,this._materialSecondPass),this._sceneSecondPass=new THREE.Scene,this._sceneSecondPass.add(this._meshSecondPass)},Core.prototype._setGeometry=function(geometryDimensions,volumeSizes){var geometryHelper=new VRC.GeometryHelper,geometry=geometryHelper.createBoxGeometry(geometryDimensions,volumeSizes,this.zFactor),colorArray=geometry.attributes.vertColor.array,positionArray=geometry.attributes.position.array;this._geometry.attributes.vertColor.array=colorArray,this._geometry.attributes.vertColor.needsUpdate=!0,this._geometry.attributes.position.array=positionArray,this._geometry.attributes.position.needsUpdate=!0,this._geometry.applyMatrix((new THREE.Matrix4).makeTranslation(-volumeSizes[0]/2,-volumeSizes[1]/2,-volumeSizes[2]/2)),this._geometry.applyMatrix((new THREE.Matrix4).makeRotationX(this._geometry_settings.rotation.x)),this._geometry.applyMatrix((new THREE.Matrix4).makeRotationY(this._geometry_settings.rotation.y)),this._geometry.applyMatrix((new THREE.Matrix4).makeRotationZ(this._geometry_settings.rotation.z)),this._geometry.doubleSided=!0},Core.prototype.setSlicemapsImages=function(images,imagesPaths){console.log("Core: setSlicemapsImages()"),this._slicemaps_images=images,this._slicemaps_paths=void 0!=imagesPaths?imagesPaths:this._slicemaps_paths,this._setSlicemapsTextures(images),this._secondPassSetUniformValue("uSliceMaps",this._slicemaps_textures)},Core.prototype.setSteps=function(steps){this._steps=steps,this._secondPassSetUniformValue("uSteps",this._steps)},Core.prototype.setSlicesRange=function(from,to){console.log("Core: setSlicesRange()"),this._slices_gap=[from,to],this._secondPassSetUniformValue("uNumberOfSlices",this.getSlicesRange()[1])},Core.prototype.setOpacityFactor=function(opacity_factor){console.log("Core: setOpacityFactor()"),this._opacity_factor=opacity_factor,this._secondPassSetUniformValue("uOpacityVal",this._opacity_factor)},Core.prototype.setColorFactor=function(color_factor){console.log("Core: setColorFactor()"),this._color_factor=color_factor,this._secondPassSetUniformValue("darkness",this._color_factor)},Core.prototype.setAbsorptionMode=function(mode_index){console.log("Core: setAbsorptionMode()"),this._absorption_mode_index=mode_index,this._secondPassSetUniformValue("uAbsorptionModeIndex",this._absorption_mode_index)},Core.prototype.setVolumeSize=function(width,height,depth){console.log("Core: setVolumeSize()"),this._volume_sizes=[width,height,depth];var maxSize=Math.max(this.getVolumeSize()[0],this.getVolumeSize()[1],this.getVolumeSize()[2]),normalizedVolumeSizes=[this.getVolumeSize()[0]/maxSize,this.getVolumeSize()[1]/maxSize,this.getVolumeSize()[2]/maxSize];this._setGeometry(this.getGeometryDimensions(),normalizedVolumeSizes)},Core.prototype.setGeometryDimensions=function(geometryDimension){console.log("Core: setGeometryDimension()"),this._geometry_dimensions=geometryDimension,this._setGeometry(this._geometry_dimensions,this.getVolumeSizeNormalized())},Core.prototype.setRenderCanvasSize=function(width,height){console.log("Core: setRenderCanvasSize()"),this._canvas_size=[width,height],"*"!=this._canvas_size[0]&&"*"!=this._canvas_size[1]||this.onResizeWindow.isStart(this._onWindowResizeFuncIndex_canvasSize)||this.onResizeWindow.start(this._onWindowResizeFuncIndex_canvasSize),"*"==this._canvas_size[0]&&"*"==this._canvas_size[1]||!this.onResizeWindow.isStart(this._onWindowResizeFuncIndex_canvasSize)||this.onResizeWindow.stop(this._onWindowResizeFuncIndex_canvasSize);var width=this.getCanvasSizeInPixels()[0],height=this.getCanvasSizeInPixels()[1];this._render.domElement.style.width=width+"px",this._render.domElement.style.height=height+"px",this._camera.aspect=width/height,this._camera.updateProjectionMatrix()},Core.prototype.setBackgroundColor=function(color){console.log("Core: setBackgroundColor()"),this._render_clear_color=color,this._render.setClearColor(color)},Core.prototype.setRowCol=function(row,col){console.log("Core: setRowCol()"),this._slicemap_row_col=[row,col],this._secondPassSetUniformValue("uSlicesOverX",this._slicemap_row_col[0]),this._secondPassSetUniformValue("uSlicesOverY",this._slicemap_row_col[1])},Core.prototype.setGrayMinValue=function(value){console.log("Core: setMinGrayValue()"),this._gray_value[0]=value,this._secondPassSetUniformValue("uMinGrayVal",this._gray_value[0])},Core.prototype.applyThresholding=function(threshold_name){switch(console.log("Core: applyThresholding()"),threshold_name){case"otsu":this.setGrayMinValue(this._threshold_otsu_index);break;case"isodata":this.setGrayMinValue(this._threshold_isodata_index);break;case"yen":this.setGrayMinValue(this._threshold_yen_index);break;case"li":this.setGrayMinValue(this._threshold_li_index)}},Core.prototype.setThresholdIndexes=function(otsu,isodata,yen,li){console.log("Core: setThresholdIndexes()"),this._threshold_otsu_index=otsu,this._threshold_isodata_index=isodata,this._threshold_yen_index=yen,this._threshold_li_index=li},Core.prototype.setGrayMaxValue=function(value){console.log("Core: setMaxGrayValue()"),this._gray_value[1]=value,this._secondPassSetUniformValue("uMaxGrayVal",this._gray_value[1])},Core.prototype.setAxis=function(value){console.log("Core: setAxis()"),console.log("Axis status: "+this.isAxisOn),this.isAxisOn?(this._sceneSecondPass.remove(this._axes),this.isAxisOn=!1):(this._sceneSecondPass.add(this._axes),this.isAxisOn=!0),this._controls.update(),this._render.render(this._sceneFirstPass,this._camera,this._rtTexture,!0),this._render.render(this._sceneFirstPass,this._camera),this._render.render(this._sceneSecondPass,this._camera)},Core.prototype.draw=function(fps){this.onPreDraw.call(fps.toFixed(3)),this._controls.update(),this._render.render(this._sceneFirstPass,this._camera,this._rtTexture,!0),this._render.render(this._sceneFirstPass,this._camera),this._render.render(this._sceneSecondPass,this._camera),this.onPostDraw.call(fps.toFixed(3))},Core.prototype.getDOMContainer=function(){return document.getElementById(this._dom_container_id)},Core.prototype.getRenderSize=function(){var width=this._render_size[0],height=this._render_size[1];return[width,height]},Core.prototype.getRenderSizeInPixels=function(){var width=this.getRenderSize()[0],height=this.getRenderSize()[0];return"*"==this._render_size[0]&&(width=this._render.domElement.width),"*"==this._render_size[1]&&(height=this._render.domElement.height),[width,height]},Core.prototype.getCanvasSize=function(){var width=this._canvas_size[0],height=this._canvas_size[1];return[width,height]},Core.prototype.getCanvasSizeInPixels=function(){var width=this.getCanvasSize()[0],height=this.getCanvasSize()[1];return"*"==this._canvas_size[0]&&(width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth),"*"==this._canvas_size[1]&&(height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight),[width,height]},Core.prototype.getSteps=function(){return this._steps},Core.prototype.getSlicemapsImages=function(){return this._slicemaps_images},Core.prototype.getSlicemapsPaths=function(){return this._slicemaps_paths},Core.prototype.getRowCol=function(){return this._slicemap_row_col},Core.prototype.getSlicesRange=function(){var from=this._slices_gap[0],to=this._slices_gap[1];return"*"==this._slices_gap[1]&&(to=this.getRowCol()[0]*this.getRowCol()[1]*this.getSlicemapsImages().length),[from,to]},Core.prototype.getVolumeSize=function(){return this._volume_sizes},Core.prototype.getMaxStepsNumber=function(){return Math.min(this.getVolumeSize()[0],this.getVolumeSize()[1])},Core.prototype.getVolumeSizeNormalized=function(){var maxSize=Math.max(this.getVolumeSize()[0],this.getVolumeSize()[1],this.getVolumeSize()[2]),normalizedVolumeSizes=[this.getVolumeSize()[0]/maxSize,this.getVolumeSize()[1]/maxSize,this.getVolumeSize()[2]/maxSize];return normalizedVolumeSizes},Core.prototype.getGeometryDimensions=function(){return this._geometry_dimensions},Core.prototype.getGrayMinValue=function(){return this._gray_value[0]},Core.prototype.getGrayMaxValue=function(){return this._gray_value[1]},Core.prototype.getClearColor=function(){return this._render_clear_color},Core.prototype.getTransferFunctionColors=function(){return this._transfer_function_colors},Core.prototype.getOpacityFactor=function(){return this._opacity_factor},Core.prototype.getColorFactor=function(){return this._color_factor},Core.prototype.getAbsorptionMode=function(){return this._absorption_mode_index},Core.prototype.getClearColor=function(){return this._render_clear_color},Core.prototype.getDomContainerId=function(){return this._dom_container_id},Core.prototype.getMaxTexturesNumber=function(){
var number_used_textures=6,gl=this._render.getContext();return gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS)-number_used_textures},Core.prototype.getMaxTextureSize=function(){var gl=this._render.getContext();return gl.getParameter(gl.MAX_TEXTURE_SIZE)},Core.prototype.getMaxFramebuferSize=function(){var gl=this._render.getContext();return gl.getParameter(gl.MAX_RENDERBUFFER_SIZE)},Core.prototype._shaders={},window.VRC.Core=Core,window.VRC.Core.prototype._shaders.firstPass={uniforms:THREE.UniformsUtils.merge([{}]),vertexShader:["precision mediump int; ","precision mediump float; ","attribute vec4 vertColor; ","varying vec4 backColor; ","varying vec4 pos; ","void main(void) ","{ ","    backColor = vertColor; ","    pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0); ","    gl_Position = pos; ","}  "].join("\n"),fragmentShader:["precision mediump int; ","precision mediump float; ","varying vec4 backColor; ","void main(void) ","{ ","    gl_FragColor = backColor; ","} "].join("\n")},window.VRC.Core.prototype._shaders.secondPass={uniforms:THREE.UniformsUtils.merge([{uBackCoord:{type:"t",value:null},uTransferFunction:{type:"t",value:null},uSliceMaps:{type:"tv",value:[]},uNumberOfSlices:{type:"f",value:-1},uMinGrayVal:{type:"f",value:-1},uMaxGrayVal:{type:"f",value:-1},uOpacityVal:{type:"f",value:-1},uColorVal:{type:"f",value:-1},uAbsorptionModeIndex:{type:"f",value:-1},uSlicesOverX:{type:"f",value:-1},uSlicesOverY:{type:"f",value:-1},uSteps:{type:"f",value:-1},uAvailable_textures_number:{type:"i",value:0}}]),vertexShader:["precision mediump int; ","precision mediump float; ","attribute vec4 vertColor; ","varying vec4 frontColor; ","varying vec4 pos; ","void main(void) ","{ ","    frontColor = vertColor; ","    pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0); ","    gl_Position = pos; ","} "].join("\n"),fragmentShader:["#ifdef GL_FRAGMENT_PRECISION_HIGH "," // highp is supported "," precision highp int; "," precision highp float; ","#else "," // high is not supported "," precision mediump int; "," precision mediump float; ","#endif ","varying vec4 frontColor; ","varying vec4 pos; ","uniform sampler2D uBackCoord; ","uniform sampler2D uTransferFunction;","uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];","uniform float uNumberOfSlices; ","uniform float uMinGrayVal; ","uniform float uMaxGrayVal; ","uniform float uOpacityVal; ","uniform float uColorVal; ","uniform float uAbsorptionModeIndex;","uniform float uSlicesOverX; ","uniform float uSlicesOverY; ","uniform float uSteps; ","// uniform int uAvailable_textures_number;","//Acts like a texture3D using Z slices and trilinear filtering. ","float getVolumeValue(vec3 volpos)","{","    float s1Original, s2Original, s1, s2; ","    float dx1, dy1; ","    // float dx2, dy2; ","    // float value; ","    vec2 texpos1,texpos2; ","    float slicesPerSprite = uSlicesOverX * uSlicesOverY; ","    s1Original = floor(volpos.z*uNumberOfSlices); ","    // s2Original = min(s1Original + 1.0, uNumberOfSlices);","    int tex1Index = int(floor(s1Original / slicesPerSprite));","    // int tex2Index = int(floor(s2Original / slicesPerSprite));","    s1 = mod(s1Original, slicesPerSprite);","    // s2 = mod(s2Original, slicesPerSprite);","    dx1 = fract(s1/uSlicesOverX);","    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;","    // dx2 = fract(s2/uSlicesOverX);","    // dy2 = floor(s2/uSlicesOverY)/uSlicesOverY;","    texpos1.x = dx1+(volpos.x/uSlicesOverX);","    texpos1.y = dy1+(volpos.y/uSlicesOverY);","    // texpos2.x = dx2+(volpos.x/uSlicesOverX);","    // texpos2.y = dy2+(volpos.y/uSlicesOverY);","    float value1 = 0.0, value2 = 0.0; ","    // bool value1Set = false, value2Set = false;","    // int numberOfSlicemaps = int( ceil(uNumberOfSlices / (uSlicesOverX * uSlicesOverY)) );","    <% for(var i=0; i < maxTexturesNumber; i++) { %>","        if( tex1Index == <%=i%> )","        {","            value1 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","        }","        <% if( i < maxTexturesNumber-1 ) { %>","            else","        <% } %>","    <% } %>","    return value1;","    // for (int x = 0; x < gl_MaxTextureImageUnits-2; x++)","    // {","    //     if(x == numberOfSlicemaps)","    //     {","    //         break;","    //     }","    //     if(x == tex1Index) { ","    //         value1 = texture2D(uSliceMaps[x],texpos1).x; ","    //         value1Set = true; ","    //     } ","    //     if(x == tex2Index) { ","    //         value2 = texture2D(uSliceMaps[x],texpos2).x; ","    //         value2Set = true; ","    //     } ","    //     if(value1Set && value2Set) { ","    //         break; ","    //     } ","    // } ","    // return mix(value1, value2, fract(volpos.z*uNumberOfSlices)); ","} ","void main(void)","{"," vec2 texC = ((pos.xy/pos.w) + 1.0) / 2.0; "," vec4 backColor = texture2D(uBackCoord,texC); "," vec3 dir = backColor.rgb - frontColor.rgb; "," //dir /= length(dir); "," vec4 vpos = frontColor; ","//      vec3 Step = dir/uSteps; "," vec3 Step = dir/uSteps; "," vec4 accum = vec4(0, 0, 0, 0); "," vec4 sample = vec4(0.0, 0.0, 0.0, 0.0); "," vec4 colorValue = vec4(0, 0, 0, 0); "," float biggest_gray_value = 0.0; "," float opacityFactor = uOpacityVal; "," float lightFactor = uColorVal; "," // const 4095 - just example of big number "," // It because expression i > uSteps impossible "," for(float i = 0.0; i < 4095.0; i+=1.0) "," { "," // It because expression i > uSteps impossible ","     if(i == uSteps) { ","         break; ","     } ","     float gray_val = getVolumeValue(vpos.xyz); ","     if(gray_val < uMinGrayVal || gray_val > uMaxGrayVal) { ","         colorValue = vec4(0.0); ","     } else { ","         if(biggest_gray_value < gray_val) { ","            biggest_gray_value = gray_val;","         } ","         if(uAbsorptionModeIndex == 0.0) ","         { ","             vec2 tf_pos; ","             tf_pos.x = (gray_val - uMinGrayVal) / (uMaxGrayVal - uMinGrayVal); ","             tf_pos.y = 0.5; ","             colorValue = texture2D(uTransferFunction,tf_pos);","             //colorValue = vec4(tf_pos.x, tf_pos.x, tf_pos.x, 1.0); ","             sample.a = colorValue.a * opacityFactor; ","             sample.rgb = colorValue.rgb * uColorVal; ","             accum += sample; ","             if(accum.a>=1.0) ","                break; ","         } ","         if(uAbsorptionModeIndex == 1.0) ","         { ","             vec2 tf_pos; ","             tf_pos.x = (gray_val - uMinGrayVal) / (uMaxGrayVal - uMinGrayVal); ","             tf_pos.y = 0.5; ","             colorValue = texture2D(uTransferFunction,tf_pos);","             //colorValue = vec4(tf_pos.x, tf_pos.x, tf_pos.x, 1.0); ","             sample.a = colorValue.a * opacityFactor * (1.0 / uSteps); ","             sample.rgb = (1.0 - accum.a) * colorValue.rgb * sample.a * lightFactor; ","             accum += sample; ","             if(accum.a>=1.0) ","                break; ","         } ","         if(uAbsorptionModeIndex == 2.0) ","         { ","             vec2 tf_pos; ","             tf_pos.x = (biggest_gray_value - uMinGrayVal) / (uMaxGrayVal - uMinGrayVal); ","             tf_pos.y = 0.5; ","             colorValue = texture2D(uTransferFunction,tf_pos);","             //colorValue = vec4(tf_pos.x, tf_pos.x, tf_pos.x, 1.0); ","             sample.a = colorValue.a * opacityFactor; ","             sample.rgb = colorValue.rgb * uColorVal; ","             accum = sample; ","         } ","     } ","     //advance the current position ","     vpos.xyz += Step; ","     //break if the position is greater than <1, 1, 1> ","     if(vpos.x > 1.0 || vpos.y > 1.0 || vpos.z > 1.0 || vpos.x < 0.0 || vpos.y < 0.0 || vpos.z < 0.0) ","     { ","         break; ","     } "," } "," gl_FragColor = accum; ","}"].join("\n")},window.VRC.Core.prototype._shaders.secondPassAR={uniforms:THREE.UniformsUtils.merge([{uBackCoord:{type:"t",value:null},uSliceMaps:{type:"tv",value:[]},uNumberOfSlices:{type:"f",value:-1},uOpacityVal:{type:"f",value:-1},uSlicesOverX:{type:"f",value:-1},uSlicesOverY:{type:"f",value:-1},darkness:{type:"f",value:-1},minSos:{type:"f",value:-1},minRefl:{type:"f",value:-1},minAtten:{type:"f",value:-1},maxSos:{type:"f",value:-1},maxRefl:{type:"f",value:-1},maxAtten:{type:"f",value:-1},l:{type:"f",value:-1},s:{type:"f",value:-1},hMin:{type:"f",value:-1},hMax:{type:"f",value:-1}}]),vertexShader:["precision mediump int; ","precision mediump float; ","attribute vec4 vertColor; ","varying vec4 frontColor; ","varying vec4 pos; ","void main(void) ","{ ","    frontColor = vertColor; ","    pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0); ","    gl_Position = pos; ","} "].join("\n"),fragmentShader:["precision mediump int; ","precision mediump float;","varying vec4 frontColor; ","varying vec4 pos; ","uniform sampler2D uBackCoord; ","uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];","uniform float uNumberOfSlices; ","uniform float uOpacityVal; ","uniform float uSlicesOverX; ","uniform float uSlicesOverY; ","uniform float darkness;","uniform float minSos;","uniform float minRefl;","uniform float minAtten;","uniform float maxSos;","uniform float maxRefl;","uniform float maxAtten;","uniform float l; ","uniform float s; ","uniform float hMin; ","uniform float hMax; ","//Acts like a texture3D using Z slices and trilinear filtering. ","vec3 getVolumeValue(vec3 volpos)","{","    float s1Original, s2Original, s1, s2; ","    float dx1, dy1; ","    vec2 texpos1,texpos2; ","    float slicesPerSprite = uSlicesOverX * uSlicesOverY; ","    s1Original = floor(volpos.z*uNumberOfSlices);     ","    int tex1Index = int(floor(s1Original / slicesPerSprite));    ","    s1 = mod(s1Original, slicesPerSprite);","    dx1 = fract(s1/uSlicesOverX);","    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;","    texpos1.x = dx1+(volpos.x/uSlicesOverX);","    texpos1.y = dy1+(volpos.y/uSlicesOverY);","    vec3 value = vec3(0.0,0.0,0.0); ","    ","    <% for(var i=0; i < maxTexturesNumber; i++) { %>","        if( tex1Index == <%=i%> )","        {","            value = texture2D(uSliceMaps[<%=i%>],texpos1).xyz;","        }","        <% if( i < maxTexturesNumber-1 ) { %>","            else","        <% } %>","    <% } %>","    return value;","} ","// x - R, y - G, z - B","// x - H, y - S, z - V","vec3 hsv2rgb(vec3 hsv) ","{","    float     hue, p, q, t, ff;","    int        i;    ","    ","    hsv.z = (darkness-hsv.z)*l;","    hsv.y = ( 1.2 - hsv.y - hMin)/(hMax - hMin) * 360.0;    ","  ","    hue = hsv.y >= 360.0 ? hsv.y-360.0 : hsv.y;","    ","    hue /= 60.0;","    i = int(hue);","    ff = hue - float(i); ","    p = hsv.z * (1.0 - s);","    q = hsv.z * (1.0 - (s * ff));","    t = hsv.z * (1.0 - (s * (1.0 - ff)));","    if(i==0)","        return vec3(hsv.z,t,p);","    ","    else if(i==1)","      return vec3(q,hsv.z,p);","        ","    else if(i==2)     ","        return vec3(p,hsv.z,t);","        ","    else if(i==3)","        return vec3(p,q,hsv.z);","        ","    else if(i==4)","        return vec3(t,p,hsv.z);","        ","    else","        return vec3(hsv.z,p,q);","}","void main(void)","{"," const int uStepsI = 144;"," const float uStepsF = float(uStepsI);","    "," vec2 texC = ((pos.xy/pos.w) + 1.0) / 2.0; "," vec4 backColor = texture2D(uBackCoord,texC); "," vec3 dir = backColor.rgb - frontColor.rgb; "," vec4 vpos = frontColor; "," vec3 Step = dir/uStepsF; "," vec4 accum = vec4(0, 0, 0, 0); "," vec4 sample = vec4(0.0, 0.0, 0.0, 0.0); "," vec4 colorValue = vec4(0, 0, 0, 0); ","    "," float opacityFactor = uOpacityVal; ","  "," for(int i = 0; i < uStepsI; i++) "," {       ","     vec3 gray_val = getVolumeValue(vpos.xyz); ","     if(gray_val.z < 0.05 || ","         gray_val.x < minSos ||","         gray_val.x > maxSos ||       ","         gray_val.y < minAtten ||","         gray_val.y > maxAtten ||","         gray_val.z < minRefl ||","         gray_val.z > maxRefl ","       )  ","         colorValue = vec4(0.0);    ","     else { ","            colorValue.x = gray_val.x;","            colorValue.y = 1.0 - sqrt(gray_val.y);","            colorValue.z = gray_val.z;","            colorValue.w = 0.1;","              ","            sample.a = colorValue.a * opacityFactor * (1.0 / uStepsF); ","            sample.rgb = (1.0 - accum.a) * hsv2rgb(colorValue.rgb) * sample.a; ","             ","            accum += sample; ","            if(accum.a>=1.0) ","               break; ","     }    ","   ","     //advance the current position ","     vpos.xyz += Step;  ","   ","   if(vpos.x > 1.0 || vpos.y > 1.0 || vpos.z > 1.0 || vpos.x < 0.0 || vpos.y < 0.0 || vpos.z < 0.0)      ","         break;  "," } "," gl_FragColor = accum; ","}"].join("\n")},window.VRC.Core.prototype._shaders.secondPassAtten={uniforms:THREE.UniformsUtils.merge([{uBackCoord:{type:"t",value:null},uSliceMaps:{type:"tv",value:[]},uNumberOfSlices:{type:"f",value:-1},uOpacityVal:{type:"f",value:-1},uSlicesOverX:{type:"f",value:-1},uSlicesOverY:{type:"f",value:-1},darkness:{type:"f",value:-1},minSos:{type:"f",value:-1},minRefl:{type:"f",value:-1},minAtten:{type:"f",value:-1},maxSos:{type:"f",value:-1},maxRefl:{type:"f",value:-1},maxAtten:{type:"f",value:-1},l:{type:"f",value:-1},s:{type:"f",value:-1},hMin:{type:"f",value:-1},hMax:{type:"f",value:-1}}]),vertexShader:["precision mediump int; ","precision mediump float; ","attribute vec4 vertColor; ","varying vec4 frontColor; ","varying vec4 pos; ","void main(void) ","{ ","    frontColor = vertColor; ","    pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0); ","    gl_Position = pos; ","} "].join("\n"),fragmentShader:["precision mediump int; ","precision mediump float;","varying vec4 frontColor; ","varying vec4 pos; ","uniform sampler2D uBackCoord; ","uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];","uniform float uNumberOfSlices; ","uniform float uOpacityVal; ","uniform float uSlicesOverX; ","uniform float uSlicesOverY; ","uniform float darkness;","uniform float minSos;","uniform float minRefl;","uniform float minAtten;","uniform float maxSos;","uniform float maxRefl;","uniform float maxAtten;","uniform float l; ","uniform float s; ","uniform float hMin; ","uniform float hMax; ","//Acts like a texture3D using Z slices and trilinear filtering. ","vec3 getVolumeValue(vec3 volpos)","{","    float s1Original, s2Original, s1, s2; ","    float dx1, dy1; ","    vec2 texpos1,texpos2; ","    float slicesPerSprite = uSlicesOverX * uSlicesOverY; ","    s1Original = floor(volpos.z*uNumberOfSlices);     ","    int tex1Index = int(floor(s1Original / slicesPerSprite));    ","    s1 = mod(s1Original, slicesPerSprite);","    dx1 = fract(s1/uSlicesOverX);","    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;","    texpos1.x = dx1+(volpos.x/uSlicesOverX);","    texpos1.y = dy1+(volpos.y/uSlicesOverY);","    vec3 value = vec3(0.0,0.0,0.0); ","    ","    <% for(var i=0; i < maxTexturesNumber; i++) { %>","        if( tex1Index == <%=i%> )","        {","            value = texture2D(uSliceMaps[<%=i%>],texpos1).xyz;","        }","        <% if( i < maxTexturesNumber-1 ) { %>","            else","        <% } %>","    <% } %>","    return value;","} ","void main(void)","{"," const int uStepsI = 144;"," const float uStepsF = float(uStepsI);","    "," vec2 texC = ((pos.xy/pos.w) + 1.0) / 2.0; "," vec4 backColor = texture2D(uBackCoord,texC); "," vec3 dir = backColor.rgb - frontColor.rgb; "," vec4 vpos = frontColor; "," vec3 Step = dir/uStepsF; "," vec4 accum = vec4(0, 0, 0, 0); "," vec4 sample = vec4(0.0, 0.0, 0.0, 0.0); "," vec4 colorValue = vec4(0, 0, 0, 0); ","    "," float opacityFactor = uOpacityVal; ","  "," for(int i = 0; i < uStepsI; i++) "," {       ","     vec3 gray_val = getVolumeValue(vpos.xyz); ","     if(gray_val.z < 0.05 || ","         gray_val.x < minSos ||","         gray_val.x > maxSos ||       ","         gray_val.y < minAtten ||","         gray_val.y > maxAtten ||","         gray_val.z < minRefl ||","         gray_val.z > maxRefl ","       )  ","         colorValue = vec4(0.0);   ","     else { ","            colorValue.x = (darkness * 2.0 - gray_val.y) * l * 0.3;","            colorValue.w = 0.1;","              ","            sample.a = colorValue.a * opacityFactor * (1.0 / uStepsF); ","            sample.rgb = (1.0 - accum.a) * colorValue.xxx * sample.a; ","             ","            accum += sample; ","            if(accum.a>=1.0) ","               break; ","     }    ","   ","     //advance the current position ","     vpos.xyz += Step;  ","   ","   if(vpos.x > 1.0 || vpos.y > 1.0 || vpos.z > 1.0 || vpos.x < 0.0 || vpos.y < 0.0 || vpos.z < 0.0)      ","         break;  "," } "," gl_FragColor = accum; ","}"].join("\n")},window.VRC.Core.prototype._shaders.secondPassAttenMax={uniforms:THREE.UniformsUtils.merge([{uBackCoord:{type:"t",value:null},uSliceMaps:{type:"tv",value:[]},uNumberOfSlices:{type:"f",value:-1},uOpacityVal:{type:"f",value:-1},uSlicesOverX:{type:"f",value:-1},uSlicesOverY:{type:"f",value:-1},darkness:{type:"f",value:-1},minSos:{type:"f",value:-1},minRefl:{type:"f",value:-1},minAtten:{type:"f",value:-1},maxSos:{type:"f",value:-1},maxRefl:{type:"f",value:-1},maxAtten:{type:"f",value:-1},l:{type:"f",value:-1},s:{type:"f",value:-1},hMin:{type:"f",value:-1},hMax:{type:"f",value:-1}}]),vertexShader:["precision mediump int; ","precision mediump float; ","attribute vec4 vertColor; ","varying vec4 frontColor; ","varying vec4 pos; ","void main(void) ","{ ","    frontColor = vertColor; ","    pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0); ","    gl_Position = pos; ","} "].join("\n"),fragmentShader:["precision mediump int; ","precision mediump float;","varying vec4 frontColor; ","varying vec4 pos; ","uniform sampler2D uBackCoord; ","uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];","uniform float uNumberOfSlices; ","uniform float uOpacityVal; ","uniform float uSlicesOverX; ","uniform float uSlicesOverY; ","uniform float darkness;","uniform float minSos;","uniform float minRefl;","uniform float minAtten;","uniform float maxSos;","uniform float maxRefl;","uniform float maxAtten;","uniform float l; ","uniform float s; ","uniform float hMin; ","uniform float hMax; "," ","//Acts like a texture3D using Z slices and trilinear filtering. ","vec3 getVolumeValue(vec3 volpos)","{","    float s1Original, s2Original, s1, s2; ","    float dx1, dy1; ","    vec2 texpos1,texpos2; ","    float slicesPerSprite = uSlicesOverX * uSlicesOverY; ","    s1Original = floor(volpos.z*uNumberOfSlices);     ","    int tex1Index = int(floor(s1Original / slicesPerSprite));    ","    s1 = mod(s1Original, slicesPerSprite);","    dx1 = fract(s1/uSlicesOverX);","    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;","    texpos1.x = dx1+(volpos.x/uSlicesOverX);","    texpos1.y = dy1+(volpos.y/uSlicesOverY);","    vec3 value = vec3(0.0,0.0,0.0); ","    ","    <% for(var i=0; i < maxTexturesNumber; i++) { %>","        if( tex1Index == <%=i%> )","        {","            value = texture2D(uSliceMaps[<%=i%>],texpos1).xyz;","        }","        <% if( i < maxTexturesNumber-1 ) { %>","            else","        <% } %>","    <% } %>","    return value;","} ","void main(void)","{"," const int uStepsI = 144;"," const float uStepsF = float(uStepsI);","    "," vec2 texC = ((pos.xy/pos.w) + 1.0) / 2.0; "," vec4 backColor = texture2D(uBackCoord,texC); "," vec3 dir = backColor.rgb - frontColor.rgb; "," vec4 vpos = frontColor; "," vec3 Step = dir/uStepsF; "," vec4 accum = vec4(0, 0, 0, 0); "," vec4 sample = vec4(0.0, 0.0, 0.0, 0.0); "," vec4 colorValue = vec4(0, 0, 0, 0); ","    "," float biggest_gray_value = 0.0; "," float opacityFactor = uOpacityVal; ","  "," for(int i = 0; i < uStepsI; i++) "," {       ","     vec3 gray_val = getVolumeValue(vpos.xyz); ","     if(gray_val.z < 0.05 || ","         gray_val.x < minSos ||","         gray_val.x > maxSos ||       ","         gray_val.y < minAtten ||","         gray_val.y > maxAtten ||","         gray_val.z < minRefl ||","         gray_val.z > maxRefl ","       )  ","         colorValue = vec4(0.0);   ","   ","     else { ","            if(biggest_gray_value < gray_val.y)  ","              biggest_gray_value = gray_val.y;    ","             colorValue.g = (darkness * 2.0 - biggest_gray_value) * l * 0.15;","             sample.a = 0.1 * opacityFactor; ","             sample.b = colorValue.g * s * 2.0; ","             sample.g = colorValue.g; ","             sample.r = colorValue.g; ","             accum = sample; ","     }    ","   ","     //advance the current position ","     vpos.xyz += Step;  ","   ","   if(vpos.x > 1.0 || vpos.y > 1.0 || vpos.z > 1.0 || vpos.x < 0.0 || vpos.y < 0.0 || vpos.z < 0.0)      ","         break;  "," } "," gl_FragColor = accum; ","}"].join("\n")},window.VRC.Core.prototype._shaders.secondPassCutOffAtten={uniforms:THREE.UniformsUtils.merge([{uBackCoord:{type:"t",value:null},uSliceMaps:{type:"tv",value:[]},uNumberOfSlices:{type:"f",value:-1},uOpacityVal:{type:"f",value:-1},uSlicesOverX:{type:"f",value:-1},uSlicesOverY:{type:"f",value:-1},darkness:{type:"f",value:-1},minSos:{type:"f",value:-1},minRefl:{type:"f",value:-1},minAtten:{type:"f",value:-1},maxSos:{type:"f",value:-1},maxRefl:{type:"f",value:-1},maxAtten:{type:"f",value:-1},l:{type:"f",value:-1},s:{type:"f",value:-1},hMin:{type:"f",value:-1},hMax:{type:"f",value:-1}}]),vertexShader:["precision mediump int; ","precision mediump float; ","attribute vec4 vertColor; ","varying vec4 frontColor; ","varying vec4 pos; ","void main(void) ","{ ","    frontColor = vertColor; ","    pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0); ","    gl_Position = pos; ","} "].join("\n"),fragmentShader:["precision mediump int; ","precision mediump float;","varying vec4 frontColor; ","varying vec4 pos; ","uniform sampler2D uBackCoord; ","uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];","uniform float uNumberOfSlices; ","uniform float uOpacityVal; ","uniform float uSlicesOverX; ","uniform float uSlicesOverY; ","uniform float darkness;","uniform float minSos;","uniform float minRefl;","uniform float minAtten;","uniform float maxSos;","uniform float maxRefl;","uniform float maxAtten;","uniform float l; ","uniform float s; ","uniform float hMin; ","uniform float hMax;  ","//Acts like a texture3D using Z slices and trilinear filtering. ","vec3 getVolumeValue(vec3 volpos)","{","    float s1Original, s2Original, s1, s2; ","    float dx1, dy1; ","    vec2 texpos1,texpos2; ","    float slicesPerSprite = uSlicesOverX * uSlicesOverY; ","    s1Original = floor(volpos.z*uNumberOfSlices);     ","    int tex1Index = int(floor(s1Original / slicesPerSprite));    ","    s1 = mod(s1Original, slicesPerSprite);","    dx1 = fract(s1/uSlicesOverX);","    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;","    texpos1.x = dx1+(volpos.x/uSlicesOverX);","    texpos1.y = dy1+(volpos.y/uSlicesOverY);","    vec3 value = vec3(0.0,0.0,0.0); ","    ","    <% for(var i=0; i < maxTexturesNumber; i++) { %>","        if( tex1Index == <%=i%> )","        {","            value = texture2D(uSliceMaps[<%=i%>],texpos1).xyz;","        }","        <% if( i < maxTexturesNumber-1 ) { %>","            else","        <% } %>","    <% } %>","    return value;","} ","// x - R, y - G, z - B","// x - H, y - S, z - V","vec3 tumorHighlighter(vec3 hsv) ","{     ","    float     hue, p, q, t, ff;","    int        i;    ","    ","    float sat = (hsv.y>(hMin + 0.5) && hsv.y<hMax)? s : 0.0; ","    hsv.z = (darkness-hsv.z)*l;","  ","    hue = 0.0;","    i = int((hue));","    ff = hue - float(i); ","    p = hsv.z * (1.0 - sat);","    q = hsv.z * (1.0 - (sat * ff));","    t = hsv.z * (1.0 - (sat * (1.0 - ff)));","    ","     return vec3(hsv.z,t,p);","}","void main(void)","{"," const int uStepsI = 144;"," const float uStepsF = float(uStepsI);","    "," vec2 texC = ((pos.xy/pos.w) + 1.0) / 2.0; "," vec4 backColor = texture2D(uBackCoord,texC); "," vec3 dir = backColor.rgb - frontColor.rgb; "," vec4 vpos = frontColor; "," vec3 Step = dir/uStepsF; "," vec4 accum = vec4(0, 0, 0, 0); "," vec4 sample = vec4(0.0, 0.0, 0.0, 0.0); "," vec4 colorValue = vec4(0, 0, 0, 0); ","    "," float opacityFactor = uOpacityVal; "," "," for(int i = 0; i < uStepsI; i++) "," {       ","     vec3 gray_val = getVolumeValue(vpos.xyz); ","     if(gray_val.z < 0.05 || ","         gray_val.x < minSos ||","         gray_val.x > maxSos ||       ","         gray_val.y < minAtten ||","         gray_val.y > maxAtten ||","         gray_val.z < minRefl ||","         gray_val.z > maxRefl ","       )  ","         colorValue = vec4(0.0);     ","     else {             ","           colorValue.x = gray_val.x;","            colorValue.y = gray_val.y;","            colorValue.z = gray_val.z;","            colorValue.w = 0.1;","              ","            sample.a = colorValue.a * opacityFactor * (1.0 / uStepsF); ","            sample.rgb = (1.0 - accum.a) * tumorHighlighter(colorValue.rgb) * sample.a; ","            ","            accum += sample; ","            if(accum.a>=1.0) ","                break; ","     }    ","   ","     //advance the current position ","     vpos.xyz += Step;  ","   ","   if(vpos.x > 1.0 || vpos.y > 1.0 || vpos.z > 1.0 || vpos.x < 0.0 || vpos.y < 0.0 || vpos.z < 0.0)      ","         break;  "," } "," gl_FragColor = accum; ","}"].join("\n")},window.VRC.Core.prototype._shaders.secondPassCutOffSos={uniforms:THREE.UniformsUtils.merge([{uBackCoord:{type:"t",value:null},uSliceMaps:{type:"tv",value:[]},uNumberOfSlices:{type:"f",value:-1},uOpacityVal:{type:"f",value:-1},uSlicesOverX:{type:"f",value:-1},uSlicesOverY:{type:"f",value:-1},darkness:{type:"f",value:-1},minSos:{type:"f",value:-1},minRefl:{type:"f",value:-1},minAtten:{type:"f",value:-1},maxSos:{type:"f",value:-1},maxRefl:{type:"f",value:-1},maxAtten:{type:"f",value:-1},l:{type:"f",value:-1},s:{type:"f",value:-1},hMin:{type:"f",value:-1},hMax:{type:"f",value:-1}}]),vertexShader:["precision mediump int; ","precision mediump float; ","attribute vec4 vertColor; ","varying vec4 frontColor; ","varying vec4 pos; ","void main(void) ","{ ","    frontColor = vertColor; ","    pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0); ","    gl_Position = pos; ","} "].join("\n"),fragmentShader:["precision mediump int; ","precision mediump float;","varying vec4 frontColor; ","varying vec4 pos; ","uniform sampler2D uBackCoord; ","uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];","uniform float uNumberOfSlices; ","uniform float uOpacityVal; ","uniform float uSlicesOverX; ","uniform float uSlicesOverY; ","uniform float darkness;","uniform float minSos;","uniform float minRefl;","uniform float minAtten;","uniform float maxSos;","uniform float maxRefl;","uniform float maxAtten;","uniform float l; ","uniform float s; ","uniform float hMin; ","uniform float hMax;  ","//Acts like a texture3D using Z slices and trilinear filtering. ","vec3 getVolumeValue(vec3 volpos)","{","    float s1Original, s2Original, s1, s2; ","    float dx1, dy1; ","    vec2 texpos1,texpos2; ","    float slicesPerSprite = uSlicesOverX * uSlicesOverY; ","    s1Original = floor(volpos.z*uNumberOfSlices);     ","    int tex1Index = int(floor(s1Original / slicesPerSprite));    ","    s1 = mod(s1Original, slicesPerSprite);","    dx1 = fract(s1/uSlicesOverX);","    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;","    texpos1.x = dx1+(volpos.x/uSlicesOverX);","    texpos1.y = dy1+(volpos.y/uSlicesOverY);","    vec3 value = vec3(0.0,0.0,0.0); ","    ","    <% for(var i=0; i < maxTexturesNumber; i++) { %>","        if( tex1Index == <%=i%> )","        {","            value = texture2D(uSliceMaps[<%=i%>],texpos1).xyz;","        }","        <% if( i < maxTexturesNumber-1 ) { %>","            else","        <% } %>","    <% } %>","    return value;","} ","// x - R, y - G, z - B","// x - H, y - S, z - V","vec3 tumorHighlighter(vec3 hsv) ","{     ","    float     hue, p, q, t, ff;","    int        i;    ","    ","    float sat = (hsv.x>(hMin + 0.5) && hsv.x<hMax)? s : 0.0; ","    hsv.z = (darkness-hsv.z)*l;","  ","    hue = 0.0;","    i = int((hue));","    ff = hue - float(i); ","    p = hsv.z * (1.0 - sat);","    q = hsv.z * (1.0 - (sat * ff));","    t = hsv.z * (1.0 - (sat * (1.0 - ff)));","    ","     return vec3(hsv.z,t,p);","}","void main(void)","{"," const int uStepsI = 144;"," const float uStepsF = float(uStepsI);","    "," vec2 texC = ((pos.xy/pos.w) + 1.0) / 2.0; "," vec4 backColor = texture2D(uBackCoord,texC); "," vec3 dir = backColor.rgb - frontColor.rgb; "," vec4 vpos = frontColor; "," vec3 Step = dir/uStepsF; "," vec4 accum = vec4(0, 0, 0, 0); "," vec4 sample = vec4(0.0, 0.0, 0.0, 0.0); "," vec4 colorValue = vec4(0, 0, 0, 0); ","    "," float opacityFactor = uOpacityVal; "," "," for(int i = 0; i < uStepsI; i++) "," {       ","     vec3 gray_val = getVolumeValue(vpos.xyz); ","     if(gray_val.z < 0.05 || ","         gray_val.x < minSos ||","         gray_val.x > maxSos ||       ","         gray_val.y < minAtten ||","         gray_val.y > maxAtten ||","         gray_val.z < minRefl ||","         gray_val.z > maxRefl ","       )  ","         colorValue = vec4(0.0);     ","     else {             ","           colorValue.x = gray_val.x;","            colorValue.y = gray_val.y;","            colorValue.z = gray_val.z;","            colorValue.w = 0.1;","              ","            sample.a = colorValue.a * opacityFactor * (1.0 / uStepsF); ","            sample.rgb = (1.0 - accum.a) * tumorHighlighter(colorValue.rgb) * sample.a; ","            ","            accum += sample; ","            if(accum.a>=1.0) ","                break; ","     }    ","   ","     //advance the current position ","     vpos.xyz += Step;  ","   ","   if(vpos.x > 1.0 || vpos.y > 1.0 || vpos.z > 1.0 || vpos.x < 0.0 || vpos.y < 0.0 || vpos.z < 0.0)      ","         break;  "," } "," gl_FragColor = accum; ","}"].join("\n")},window.VRC.Core.prototype._shaders.secondPassFusion={uniforms:THREE.UniformsUtils.merge([{uBackCoord:{type:"t",value:null},uSliceMaps:{type:"tv",value:[]},uNumberOfSlices:{type:"f",value:-1},uOpacityVal:{type:"f",value:-1},uSlicesOverX:{type:"f",value:-1},uSlicesOverY:{type:"f",value:-1},darkness:{type:"f",value:-1},minSos:{type:"f",value:-1},minRefl:{type:"f",value:-1},minAtten:{type:"f",value:-1},maxSos:{type:"f",value:-1},maxRefl:{type:"f",value:-1},maxAtten:{type:"f",value:-1},l:{type:"f",value:-1},s:{type:"f",value:-1},hMin:{type:"f",value:-1},hMax:{type:"f",value:-1}}]),vertexShader:["precision mediump int; ","precision mediump float; ","attribute vec4 vertColor; ","varying vec4 frontColor; ","varying vec4 pos; ","void main(void) ","{ ","    frontColor = vertColor; ","    pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0); ","    gl_Position = pos; ","} "].join("\n"),fragmentShader:["precision mediump int; ","precision mediump float;","varying vec4 frontColor; ","varying vec4 pos; ","uniform sampler2D uBackCoord; ","uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];","uniform float uNumberOfSlices; ","uniform float uOpacityVal; ","uniform float uSlicesOverX; ","uniform float uSlicesOverY; ","uniform float darkness;","uniform float minSos;","uniform float minRefl;","uniform float minAtten;","uniform float maxSos;","uniform float maxRefl;","uniform float maxAtten;","uniform float l; ","uniform float s; ","uniform float hMin; ","uniform float hMax;    ","//Acts like a texture3D using Z slices and trilinear filtering. ","vec3 getVolumeValue(vec3 volpos)","{","    float s1Original, s2Original, s1, s2; ","    float dx1, dy1; ","    vec2 texpos1,texpos2; ","    float slicesPerSprite = uSlicesOverX * uSlicesOverY; ","    s1Original = floor(volpos.z*uNumberOfSlices);     ","    int tex1Index = int(floor(s1Original / slicesPerSprite));    ","    s1 = mod(s1Original, slicesPerSprite);","    dx1 = fract(s1/uSlicesOverX);","    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;","    texpos1.x = dx1+(volpos.x/uSlicesOverX);","    texpos1.y = dy1+(volpos.y/uSlicesOverY);","    vec3 value = vec3(0.0,0.0,0.0); ","    ","    <% for(var i=0; i < maxTexturesNumber; i++) { %>","        if( tex1Index == <%=i%> )","        {","            value = texture2D(uSliceMaps[<%=i%>],texpos1).xyz;","        }","        <% if( i < maxTexturesNumber-1 ) { %>","            else","        <% } %>","    <% } %>","    return value;","} ","// x - R, y - G, z - B","// x - H, y - S, z - V","vec3 hsv2rgb(vec3 hsv) ","{","    float     hue, p, q, t, ff;","    int        i;    ","    ","    hsv.z = (darkness - hsv.z) * l;","    hsv.x = (hsv.x - hMin)/(hMax - hMin) * 360.0;    ","    hsv.y *= s * 1.5;  ","  ","    hue=hsv.x >= 360.0?hsv.x-360.0:hsv.x;","    ","    hue /= 60.0;","    i = int(hue);","    ff = hue - float(i); ","    p = hsv.z * (1.0 - hsv.y);","    q = hsv.z * (1.0 - (hsv.y * ff));","    t = hsv.z * (1.0 - (hsv.y * (1.0 - ff)));","    if(i==0)","        return vec3(hsv.z,t,p);","    ","    else if(i==1)","      return vec3(q,hsv.z,p);","        ","    else if(i==2)     ","        return vec3(p,hsv.z,t);","        ","    else if(i==3)","        return vec3(p,q,hsv.z);","        ","    else if(i==4)","        return vec3(t,p,hsv.z);","        ","    else","        return vec3(hsv.z,p,q);","}","void main(void)","{"," const int uStepsI = 144;"," const float uStepsF = float(uStepsI);","    "," vec2 texC = ((pos.xy/pos.w) + 1.0) / 2.0; "," vec4 backColor = texture2D(uBackCoord,texC); "," vec3 dir = backColor.rgb - frontColor.rgb; "," vec4 vpos = frontColor; "," vec3 Step = dir/uStepsF; "," vec4 accum = vec4(0, 0, 0, 0); "," vec4 sample = vec4(0.0, 0.0, 0.0, 0.0); "," vec4 colorValue = vec4(0, 0, 0, 0); "," float opacityFactor = uOpacityVal; ","  "," for(int i = 0; i < uStepsI; i++) "," {       ","    vec3 gray_val = getVolumeValue(vpos.xyz); ","     if(gray_val.z < 0.05 || ","         gray_val.x < minSos ||","         gray_val.x > maxSos ||       ","         gray_val.y < minAtten ||","         gray_val.y > maxAtten ||","         gray_val.z < minRefl ||","         gray_val.z > maxRefl ","       )  ","         colorValue = vec4(0.0);   ","     else {         ","            colorValue.x = gray_val.x;","            colorValue.y = 1.0-gray_val.y/0.6;","            colorValue.z = gray_val.z;","            colorValue.w = 0.1;","              ","            sample.a = colorValue.a * opacityFactor * (1.0 / uStepsF); ","            sample.rgb = (1.0 - accum.a) * hsv2rgb(colorValue.rgb) * sample.a; ","             ","            accum += sample; ","            if(accum.a>=1.0) ","               break; ","     }    ","   ","     //advance the current position ","     vpos.xyz += Step;  ","   ","   if(vpos.x > 1.0 || vpos.y > 1.0 || vpos.z > 1.0 || vpos.x < 0.0 || vpos.y < 0.0 || vpos.z < 0.0)      ","         break;  "," } "," gl_FragColor = accum; ","}"].join("\n")
},window.VRC.Core.prototype._shaders.secondPassLidar={uniforms:THREE.UniformsUtils.merge([{uBackCoord:{type:"t",value:null},uTransferFunction:{type:"t",value:null},uSliceMaps:{type:"tv",value:[]},uNumberOfSlices:{type:"f",value:-1},uMinGrayVal:{type:"f",value:-1},uMaxGrayVal:{type:"f",value:-1},uOpacityVal:{type:"f",value:-1},uColorVal:{type:"f",value:-1},uSlicesOverX:{type:"f",value:-1},uSlicesOverY:{type:"f",value:-1}}]),vertexShader:["precision mediump int; ","precision mediump float; ","attribute vec4 vertColor; ","varying vec4 frontColor; ","varying vec4 pos; ","void main(void) ","{ ","    frontColor = vertColor; ","    pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0); ","    gl_Position = pos; ","} "].join("\n"),fragmentShader:["precision mediump int; ","precision mediump float; ","varying vec4 frontColor; ","varying vec4 pos; ","uniform sampler2D uBackCoord; ","uniform sampler2D uTransferFunction;","uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];","uniform float uNumberOfSlices; ","uniform float uMinGrayVal; ","uniform float uMaxGrayVal; ","uniform float uOpacityVal; ","uniform float uColorVal; ","uniform float uSlicesOverX; ","uniform float uSlicesOverY; ","//Acts like a texture3D using Z slices and trilinear filtering. ","float getVolumeValue(vec3 volpos) {","    float s1Original, s2Original, s1, s2; ","    float dx1, dy1; ","    // float dx2, dy2; ","    // float value; ","    vec2 texpos1,texpos2; ","    float slicesPerSprite = uSlicesOverX * uSlicesOverY; ","    s1Original = floor(volpos.z*uNumberOfSlices); ","    int tex1Index = int(floor(s1Original / slicesPerSprite));","    s1 = mod(s1Original, slicesPerSprite);","    dx1 = fract(s1/uSlicesOverX);","    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;","    texpos1.x = dx1+(volpos.x/uSlicesOverX);","    texpos1.y = dy1+(volpos.y/uSlicesOverY);","    float value1 = 0.0, value2 = 0.0; ","    <% for(var i=0; i < maxTexturesNumber; i++) { %>","        if( tex1Index == <%=i%> )","        {","            value1 = texture2D(uSliceMaps[<%=i%>],texpos1).x;","        }","        <% if( i < maxTexturesNumber-1 ) { %>","            else","        <% } %>","    <% } %>","    return value1;","} ","void main(void) {","    const int uStepsI = 144;","    const float uStepsF = float(uStepsI);","    vec2 texC = ((pos.xy/pos.w) + 1.0) / 2.0; ","    vec4 backColor = texture2D(uBackCoord,texC); ","    vec3 dir = backColor.rgb - frontColor.rgb; ","    vec4 vpos = frontColor; ","    vec3 Step = dir/uStepsF; ","    vec4 accum = vec4(0, 0, 0, 0); ","    vec4 sample = vec4(0.0, 0.0, 0.0, 0.0); ","    vec4 colorValue = vec4(0, 0, 0, 0); ","    float biggest_gray_value = 0.0; ","    float opacityFactor = uOpacityVal; ","    float lightFactor = uColorVal; ","    // const 4095 - just example of big number ","    // It because expression i > uSteps impossible ","    for(int i = 0; i < uStepsI; i++) { ","        // It because expression i > uSteps impossible ","        if(i == uStepsI) { ","            break; ","        } ","        float gray_val = getVolumeValue(vpos.xyz); ","        if (gray_val < uMinGrayVal || gray_val > uMaxGrayVal) { ","            colorValue = vec4(0.0); ","        } else { ","            if(biggest_gray_value < gray_val) { ","                biggest_gray_value = gray_val;","            } ","            vec2 tf_pos; ","            tf_pos.x = (gray_val - uMinGrayVal) / (uMaxGrayVal - uMinGrayVal); ","            tf_pos.y = 0.5; ","            colorValue = texture2D(uTransferFunction,tf_pos);","            sample.a = colorValue.a * opacityFactor * (1.0 / uStepsF); ","            sample.rgb = (1.0 - accum.a) * colorValue.rgb * sample.a * lightFactor; ","            accum += sample; ","            if(accum.a>=1.0) ","                break;","        } ","        //advance the current position ","        vpos.xyz += Step; ","        //break if the position is greater than <1, 1, 1> ","        if(vpos.x > 1.0 || vpos.y > 1.0 || vpos.z > 1.0 || vpos.x < 0.0 || vpos.y < 0.0 || vpos.z < 0.0) { ","            break; ","        }","    }","    gl_FragColor = accum; ","}"].join("\n")},window.VRC.Core.prototype._shaders.secondPassRB={uniforms:THREE.UniformsUtils.merge([{uBackCoord:{type:"t",value:null},uSliceMaps:{type:"tv",value:[]},uNumberOfSlices:{type:"f",value:-1},uOpacityVal:{type:"f",value:-1},uSlicesOverX:{type:"f",value:-1},uSlicesOverY:{type:"f",value:-1},darkness:{type:"f",value:-1},minSos:{type:"f",value:-1},minRefl:{type:"f",value:-1},minAtten:{type:"f",value:-1},maxSos:{type:"f",value:-1},maxRefl:{type:"f",value:-1},maxAtten:{type:"f",value:-1},l:{type:"f",value:-1},s:{type:"f",value:-1},hMin:{type:"f",value:-1},hMax:{type:"f",value:-1}}]),vertexShader:["precision mediump int; ","precision mediump float; ","attribute vec4 vertColor; ","varying vec4 frontColor; ","varying vec4 pos; ","void main(void) ","{ ","    frontColor = vertColor; ","    pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0); ","    gl_Position = pos; ","} "].join("\n"),fragmentShader:["precision mediump int; ","precision mediump float;","varying vec4 frontColor; ","varying vec4 pos; ","uniform sampler2D uBackCoord; ","uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];","uniform float uNumberOfSlices; ","uniform float uOpacityVal; ","uniform float uSlicesOverX; ","uniform float uSlicesOverY; ","uniform float darkness;","uniform float minSos;","uniform float minRefl;","uniform float minAtten;","uniform float maxSos;","uniform float maxRefl;","uniform float maxAtten;","uniform float l; ","uniform float s; ","uniform float hMin; ","uniform float hMax; ","//Acts like a texture3D using Z slices and trilinear filtering. ","vec3 getVolumeValue(vec3 volpos)","{","    float s1Original, s2Original, s1, s2; ","    float dx1, dy1; ","    vec2 texpos1,texpos2; ","    float slicesPerSprite = uSlicesOverX * uSlicesOverY; ","    s1Original = floor(volpos.z*uNumberOfSlices);     ","    int tex1Index = int(floor(s1Original / slicesPerSprite));    ","    s1 = mod(s1Original, slicesPerSprite);","    dx1 = fract(s1/uSlicesOverX);","    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;","    texpos1.x = dx1+(volpos.x/uSlicesOverX);","    texpos1.y = dy1+(volpos.y/uSlicesOverY);","    vec3 value = vec3(0.0,0.0,0.0); ","    ","    <% for(var i=0; i < maxTexturesNumber; i++) { %>","        if( tex1Index == <%=i%> )","        {","            value = texture2D(uSliceMaps[<%=i%>],texpos1).xyz;","        }","        <% if( i < maxTexturesNumber-1 ) { %>","            else","        <% } %>","    <% } %>","    return value;","} ","// x - R, y - G, z - B","// x - H, y - S, z - V","vec3 realBody(vec3 hsv) ","{    ","    float     hue, p, q, t, ff;","    int        i;    ","    ","    hsv.z = (darkness - hsv.z) * l;","        ","    hsv.x = (hsv.x - hMin)/(hMax - hMin) * 360.0;    ","        ","    hue=hsv.x >= 360.0 ? 360.0 : hsv.x;","    ","    hue /= 230.0;","    i = int((hue));","    ff = hue - float(i); ","    p = hsv.z * (1.0 - s);","    q = hsv.z * (1.0 - (s * ff));","    t = hsv.z * (1.0 - (s * (1.0 - ff)));","    return vec3(hsv.z,t,p);    ","}","void main(void)","{"," const int uStepsI = 144;"," const float uStepsF = float(uStepsI);","    "," vec2 texC = ((pos.xy/pos.w) + 1.0) / 2.0; "," vec4 backColor = texture2D(uBackCoord,texC); "," vec3 dir = backColor.rgb - frontColor.rgb; "," vec4 vpos = frontColor; "," vec3 Step = dir/uStepsF; "," vec4 accum = vec4(0, 0, 0, 0); "," vec4 sample = vec4(0.0, 0.0, 0.0, 0.0); "," vec4 colorValue = vec4(0, 0, 0, 0); ","    "," float opacityFactor = uOpacityVal; ","  "," for(int i = 0; i < uStepsI; i++) "," {       ","    vec3 gray_val = getVolumeValue(vpos.xyz); ","     if(gray_val.z < 0.05 || ","         gray_val.x < minSos ||","         gray_val.x > maxSos ||       ","         gray_val.y < minAtten ||","         gray_val.y > maxAtten ||","         gray_val.z < minRefl ||","         gray_val.z > maxRefl ","       )  ","         colorValue = vec4(0.0);   ","     else {              ","            colorValue.x = gray_val.x;","            colorValue.y = gray_val.y;","            colorValue.z = gray_val.z;","            colorValue.w = 0.1;","              ","            sample.a = colorValue.a * opacityFactor * (1.0 / uStepsF); ","            sample.rgb = (1.0 - accum.a) * realBody(colorValue.rgb) * sample.a ;          ","             ","            accum += sample; ","            if(accum.a>=1.0) ","                break; ","     }    ","   ","     //advance the current position ","     vpos.xyz += Step;  ","   ","   if(vpos.x > 1.0 || vpos.y > 1.0 || vpos.z > 1.0 || vpos.x < 0.0 || vpos.y < 0.0 || vpos.z < 0.0)      ","         break;  "," } "," gl_FragColor = accum; ","}"].join("\n")},window.VRC.Core.prototype._shaders.secondPassRefl={uniforms:THREE.UniformsUtils.merge([{uBackCoord:{type:"t",value:null},uSliceMaps:{type:"tv",value:[]},uNumberOfSlices:{type:"f",value:-1},uOpacityVal:{type:"f",value:-1},uSlicesOverX:{type:"f",value:-1},uSlicesOverY:{type:"f",value:-1},darkness:{type:"f",value:-1},minSos:{type:"f",value:-1},minRefl:{type:"f",value:-1},minAtten:{type:"f",value:-1},maxSos:{type:"f",value:-1},maxRefl:{type:"f",value:-1},maxAtten:{type:"f",value:-1},l:{type:"f",value:-1},s:{type:"f",value:-1},hMin:{type:"f",value:-1},hMax:{type:"f",value:-1}}]),vertexShader:["precision mediump int; ","precision mediump float; ","attribute vec4 vertColor; ","varying vec4 frontColor; ","varying vec4 pos; ","void main(void) ","{ ","    frontColor = vertColor; ","    pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0); ","    gl_Position = pos; ","} "].join("\n"),fragmentShader:["precision mediump int; ","precision mediump float;","varying vec4 frontColor; ","varying vec4 pos; ","uniform sampler2D uBackCoord; ","uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];","uniform float uNumberOfSlices; ","uniform float uOpacityVal; ","uniform float uSlicesOverX; ","uniform float uSlicesOverY; ","uniform float darkness;","uniform float minSos;","uniform float minRefl;","uniform float minAtten;","uniform float maxSos;","uniform float maxRefl;","uniform float maxAtten;","uniform float l; ","uniform float s; ","uniform float hMin; ","uniform float hMax;  ","//Acts like a texture3D using Z slices and trilinear filtering. ","vec3 getVolumeValue(vec3 volpos)","{","    float s1Original, s2Original, s1, s2; ","    float dx1, dy1; ","    vec2 texpos1,texpos2; ","    float slicesPerSprite = uSlicesOverX * uSlicesOverY; ","    s1Original = floor(volpos.z*uNumberOfSlices);     ","    int tex1Index = int(floor(s1Original / slicesPerSprite));    ","    s1 = mod(s1Original, slicesPerSprite);","    dx1 = fract(s1/uSlicesOverX);","    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;","    texpos1.x = dx1+(volpos.x/uSlicesOverX);","    texpos1.y = dy1+(volpos.y/uSlicesOverY);","    vec3 value = vec3(0.0,0.0,0.0); ","    ","    <% for(var i=0; i < maxTexturesNumber; i++) { %>","        if( tex1Index == <%=i%> )","        {","            value = texture2D(uSliceMaps[<%=i%>],texpos1).xyz;","        }","        <% if( i < maxTexturesNumber-1 ) { %>","            else","        <% } %>","    <% } %>","    return value;","} ","void main(void)","{"," const int uStepsI = 144;"," const float uStepsF = float(uStepsI);","    "," vec2 texC = ((pos.xy/pos.w) + 1.0) / 2.0; "," vec4 backColor = texture2D(uBackCoord,texC); "," vec3 dir = backColor.rgb - frontColor.rgb; "," vec4 vpos = frontColor; "," vec3 Step = dir/uStepsF; "," vec4 accum = vec4(0, 0, 0, 0); "," vec4 sample = vec4(0.0, 0.0, 0.0, 0.0); "," vec4 colorValue = vec4(0, 0, 0, 0); ","    "," float opacityFactor = uOpacityVal; ","  "," for(int i = 0; i < uStepsI; i++) "," {       ","    vec3 gray_val = getVolumeValue(vpos.xyz); ","     if(gray_val.z < 0.05 || ","         gray_val.x < minSos ||","         gray_val.x > maxSos ||       ","         gray_val.y < minAtten ||","         gray_val.y > maxAtten ||","         gray_val.z < minRefl ||","         gray_val.z > maxRefl ","       )  ","         colorValue = vec4(0.0);   ","     else { ","            colorValue.x = (darkness - gray_val.z) * l;","            colorValue.w = 0.1;","              ","            sample.a = colorValue.a * opacityFactor * (1.0 / uStepsF); ","            sample.rgb = (1.0 - accum.a) * colorValue.xxx * sample.a; ","             ","            accum += sample; ","            if(accum.a>=1.0) ","               break; ","     }    ","   ","     //advance the current position ","     vpos.xyz += Step;  ","   ","   if(vpos.x > 1.0 || vpos.y > 1.0 || vpos.z > 1.0 || vpos.x < 0.0 || vpos.y < 0.0 || vpos.z < 0.0)      ","         break;  "," } "," gl_FragColor = accum; ","}"].join("\n")},window.VRC.Core.prototype._shaders.secondPassSR={uniforms:THREE.UniformsUtils.merge([{uBackCoord:{type:"t",value:null},uSliceMaps:{type:"tv",value:[]},uNumberOfSlices:{type:"f",value:-1},uOpacityVal:{type:"f",value:-1},uSlicesOverX:{type:"f",value:-1},uSlicesOverY:{type:"f",value:-1},darkness:{type:"f",value:-1},minSos:{type:"f",value:-1},minRefl:{type:"f",value:-1},minAtten:{type:"f",value:-1},maxSos:{type:"f",value:-1},maxRefl:{type:"f",value:-1},maxAtten:{type:"f",value:-1},l:{type:"f",value:-1},s:{type:"f",value:-1},hMin:{type:"f",value:-1},hMax:{type:"f",value:-1}}]),vertexShader:["precision mediump int; ","precision mediump float; ","attribute vec4 vertColor; ","varying vec4 frontColor; ","varying vec4 pos; ","void main(void) ","{ ","    frontColor = vertColor; ","    pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0); ","    gl_Position = pos; ","} "].join("\n"),fragmentShader:["precision mediump int; ","precision mediump float;","varying vec4 frontColor; ","varying vec4 pos; ","uniform sampler2D uBackCoord; ","uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];","uniform float uNumberOfSlices; ","uniform float uOpacityVal; ","uniform float uSlicesOverX; ","uniform float uSlicesOverY; ","uniform float darkness;","uniform float minSos;","uniform float minRefl;","uniform float minAtten;","uniform float maxSos;","uniform float maxRefl;","uniform float maxAtten;","uniform float l; ","uniform float s; ","uniform float hMin; ","uniform float hMax; ","//Acts like a texture3D using Z slices and trilinear filtering. ","vec3 getVolumeValue(vec3 volpos)","{","    float s1Original, s2Original, s1, s2; ","    float dx1, dy1; ","    vec2 texpos1,texpos2; ","    float slicesPerSprite = uSlicesOverX * uSlicesOverY; ","    s1Original = floor(volpos.z*uNumberOfSlices);     ","    int tex1Index = int(floor(s1Original / slicesPerSprite));    ","    s1 = mod(s1Original, slicesPerSprite);","    dx1 = fract(s1/uSlicesOverX);","    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;","    texpos1.x = dx1+(volpos.x/uSlicesOverX);","    texpos1.y = dy1+(volpos.y/uSlicesOverY);","    vec3 value = vec3(0.0,0.0,0.0); ","    ","    <% for(var i=0; i < maxTexturesNumber; i++) { %>","        if( tex1Index == <%=i%> )","        {","            value = texture2D(uSliceMaps[<%=i%>],texpos1).xyz;","        }","        <% if( i < maxTexturesNumber-1 ) { %>","            else","        <% } %>","    <% } %>","    return value;","} ","// x - R, y - G, z - B","// x - H, y - S, z - V","vec3 hsv2rgb(vec3 hsv) ","{","    float     hue, p, q, t, ff, sat;","    int        i;    ","    ","    hsv.z = (darkness-hsv.z)*l;","    hsv.x = (hsv.x - hMin)/(hMax - hMin) * 360.0; ","  ","    hue = hsv.x >= 360.0 ? hsv.x-360.0 : hsv.x;","    ","    sat = s;","    ","    hue /= 60.0;","    i = int(hue);","    ff = hue - float(i); ","    p = hsv.z * (1.0 - sat);","    q = hsv.z * (1.0 - (sat * ff));","    t = hsv.z * (1.0 - (sat * (1.0 - ff)));","    if(i==0)","        return vec3(hsv.z,t,p);","    ","    else if(i==1)","      return vec3(q,hsv.z,p);","        ","    else if(i==2)     ","        return vec3(p,hsv.z,t);","        ","    else if(i==3)","        return vec3(p,q,hsv.z);","        ","    else if(i==4)","        return vec3(t,p,hsv.z);","        ","    else","        return vec3(hsv.z,p,q);","}","void main(void)","{"," const int uStepsI = 144;"," const float uStepsF = float(uStepsI);","    "," vec2 texC = ((pos.xy/pos.w) + 1.0) / 2.0; "," vec4 backColor = texture2D(uBackCoord,texC); "," vec3 dir = backColor.rgb - frontColor.rgb; "," vec4 vpos = frontColor; "," vec3 Step = dir/uStepsF; "," vec4 accum = vec4(0, 0, 0, 0); "," vec4 sample = vec4(0.0, 0.0, 0.0, 0.0); "," vec4 colorValue = vec4(0, 0, 0, 0); ","    "," float opacityFactor = uOpacityVal; ","  "," for(int i = 0; i < uStepsI; i++) "," {       ","     vec3 gray_val = getVolumeValue(vpos.xyz); ","     if(gray_val.z < 0.05 || ","         gray_val.x < minSos ||","         gray_val.x > maxSos ||       ","         gray_val.y < minAtten ||","         gray_val.y > maxAtten ||","         gray_val.z < minRefl ||","         gray_val.z > maxRefl ","       )  ","         colorValue = vec4(0.0);    ","     else { ","            colorValue.x = gray_val.x;","            colorValue.y = 1.0 - sqrt(gray_val.y);","            colorValue.z = gray_val.z;","            colorValue.w = 0.1;","              ","            sample.a = colorValue.a * opacityFactor * (1.0 / uStepsF); ","            sample.rgb = (1.0 - accum.a) * hsv2rgb(colorValue.rgb) * sample.a; ","             ","            accum += sample; ","            if(accum.a>=1.0) ","               break; ","     }    ","   ","     //advance the current position ","     vpos.xyz += Step;  ","   ","   if(vpos.x > 1.0 || vpos.y > 1.0 || vpos.z > 1.0 || vpos.x < 0.0 || vpos.y < 0.0 || vpos.z < 0.0)      ","         break;  "," } "," gl_FragColor = accum; ","}"].join("\n")},window.VRC.Core.prototype._shaders.secondPassSos={uniforms:THREE.UniformsUtils.merge([{uBackCoord:{type:"t",value:null},uSliceMaps:{type:"tv",value:[]},uNumberOfSlices:{type:"f",value:-1},uOpacityVal:{type:"f",value:-1},uSlicesOverX:{type:"f",value:-1},uSlicesOverY:{type:"f",value:-1},darkness:{type:"f",value:-1},minSos:{type:"f",value:-1},minRefl:{type:"f",value:-1},minAtten:{type:"f",value:-1},maxSos:{type:"f",value:-1},maxRefl:{type:"f",value:-1},maxAtten:{type:"f",value:-1},l:{type:"f",value:-1},s:{type:"f",value:-1},hMin:{type:"f",value:-1},hMax:{type:"f",value:-1}}]),vertexShader:["precision mediump int; ","precision mediump float; ","attribute vec4 vertColor; ","varying vec4 frontColor; ","varying vec4 pos; ","void main(void) ","{ ","    frontColor = vertColor; ","    pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0); ","    gl_Position = pos; ","} "].join("\n"),fragmentShader:["precision mediump int; ","precision mediump float;","varying vec4 frontColor; ","varying vec4 pos; ","uniform sampler2D uBackCoord; ","uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];","uniform float uNumberOfSlices; ","uniform float uOpacityVal; ","uniform float uSlicesOverX; ","uniform float uSlicesOverY; ","uniform float darkness;","uniform float minSos;","uniform float minRefl;","uniform float minAtten;","uniform float maxSos;","uniform float maxRefl;","uniform float maxAtten;","uniform float l; ","uniform float s; ","uniform float hMin; ","uniform float hMax; ","//Acts like a texture3D using Z slices and trilinear filtering. ","vec3 getVolumeValue(vec3 volpos)","{","    float s1Original, s2Original, s1, s2; ","    float dx1, dy1; ","    vec2 texpos1,texpos2; ","    float slicesPerSprite = uSlicesOverX * uSlicesOverY; ","    s1Original = floor(volpos.z*uNumberOfSlices);     ","    int tex1Index = int(floor(s1Original / slicesPerSprite));    ","    s1 = mod(s1Original, slicesPerSprite);","    dx1 = fract(s1/uSlicesOverX);","    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;","    texpos1.x = dx1+(volpos.x/uSlicesOverX);","    texpos1.y = dy1+(volpos.y/uSlicesOverY);","    vec3 value = vec3(0.0,0.0,0.0); ","    ","    <% for(var i=0; i < maxTexturesNumber; i++) { %>","        if( tex1Index == <%=i%> )","        {","            value = texture2D(uSliceMaps[<%=i%>],texpos1).xyz;","        }","        <% if( i < maxTexturesNumber-1 ) { %>","            else","        <% } %>","    <% } %>","    return value;","} ","void main(void)","{"," const int uStepsI = 144;"," const float uStepsF = float(uStepsI);","    "," vec2 texC = ((pos.xy/pos.w) + 1.0) / 2.0; "," vec4 backColor = texture2D(uBackCoord,texC); "," vec3 dir = backColor.rgb - frontColor.rgb; "," vec4 vpos = frontColor; "," vec3 Step = dir/uStepsF; "," vec4 accum = vec4(0, 0, 0, 0); "," vec4 sample = vec4(0.0, 0.0, 0.0, 0.0); "," vec4 colorValue = vec4(0, 0, 0, 0); ","    "," float opacityFactor = uOpacityVal; ","  "," for(int i = 0; i < uStepsI; i++) "," {       ","     vec3 gray_val = getVolumeValue(vpos.xyz); ","     if(gray_val.z < 0.05 || ","         gray_val.x < minSos ||","         gray_val.x > maxSos ||       ","         gray_val.y < minAtten ||","         gray_val.y > maxAtten ||","         gray_val.z < minRefl ||","         gray_val.z > maxRefl ","       )  ","         colorValue = vec4(0.0);     ","     else { ","            colorValue.x = (darkness * 2.0 - gray_val.x) * l * 0.4;","            colorValue.w = 0.1;","              ","            sample.a = colorValue.a * opacityFactor * (1.0 / uStepsF); ","            sample.rgb = (1.0 - accum.a) * colorValue.xxx * sample.a; ","             ","            accum += sample; ","            if(accum.a>=1.0) ","               break; ","     }    ","   ","     //advance the current position ","     vpos.xyz += Step;  ","   ","   if(vpos.x > 1.0 || vpos.y > 1.0 || vpos.z > 1.0 || vpos.x < 0.0 || vpos.y < 0.0 || vpos.z < 0.0)      ","         break;  "," } "," gl_FragColor = accum; ","}"].join("\n")},window.VRC.Core.prototype._shaders.secondPassSosMax={uniforms:THREE.UniformsUtils.merge([{uBackCoord:{type:"t",value:null},uSliceMaps:{type:"tv",value:[]},uNumberOfSlices:{type:"f",value:-1},uOpacityVal:{type:"f",value:-1},uSlicesOverX:{type:"f",value:-1},uSlicesOverY:{type:"f",value:-1},darkness:{type:"f",value:-1},minSos:{type:"f",value:-1},minRefl:{type:"f",value:-1},minAtten:{type:"f",value:-1},maxSos:{type:"f",value:-1},maxRefl:{type:"f",value:-1},maxAtten:{type:"f",value:-1},l:{type:"f",value:-1},s:{type:"f",value:-1},hMin:{type:"f",value:-1},hMax:{type:"f",value:-1},uAvailable_textures_number:{type:"i",value:0}}]),vertexShader:["precision mediump int; ","precision mediump float; ","attribute vec4 vertColor; ","varying vec4 frontColor; ","varying vec4 pos; ","void main(void) ","{ ","    frontColor = vertColor; ","    pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0); ","    gl_Position = pos; ","} "].join("\n"),fragmentShader:["precision mediump int; ","precision mediump float;","varying vec4 frontColor; ","varying vec4 pos; ","uniform sampler2D uBackCoord; ","uniform sampler2D uSliceMaps[<%= maxTexturesNumber %>];","uniform float uNumberOfSlices; ","uniform float uOpacityVal; ","uniform float uSlicesOverX; ","uniform float uSlicesOverY; ","uniform float darkness;","uniform float minSos;","uniform float minRefl;","uniform float minAtten;","uniform float maxSos;","uniform float maxRefl;","uniform float maxAtten;","uniform float l; ","uniform float s; ","uniform float hMin; ","uniform float hMax;  "," ","// uniform int uAvailable_textures_number;","//Acts like a texture3D using Z slices and trilinear filtering. ","vec3 getVolumeValue(vec3 volpos)","{","    float s1Original, s2Original, s1, s2; ","    float dx1, dy1; ","    vec2 texpos1,texpos2; ","    float slicesPerSprite = uSlicesOverX * uSlicesOverY; ","    s1Original = floor(volpos.z*uNumberOfSlices);     ","    int tex1Index = int(floor(s1Original / slicesPerSprite));    ","    s1 = mod(s1Original, slicesPerSprite);","    dx1 = fract(s1/uSlicesOverX);","    dy1 = floor(s1/uSlicesOverY)/uSlicesOverY;","    texpos1.x = dx1+(volpos.x/uSlicesOverX);","    texpos1.y = dy1+(volpos.y/uSlicesOverY);","    vec3 value = vec3(0.0,0.0,0.0); ","    ","    <% for(var i=0; i < maxTexturesNumber; i++) { %>","        if( tex1Index == <%=i%> )","        {","            value = texture2D(uSliceMaps[<%=i%>],texpos1).xyz;","        }","        <% if( i < maxTexturesNumber-1 ) { %>","            else","        <% } %>","    <% } %>","    return value;","} ","void main(void)","{"," const int uStepsI = 144;"," const float uStepsF = float(uStepsI);","    "," vec2 texC = ((pos.xy/pos.w) + 1.0) / 2.0; "," vec4 backColor = texture2D(uBackCoord,texC); "," vec3 dir = backColor.rgb - frontColor.rgb; "," vec4 vpos = frontColor; "," vec3 Step = dir/uStepsF; "," vec4 accum = vec4(0, 0, 0, 0); "," vec4 sample = vec4(0.0, 0.0, 0.0, 0.0); "," vec4 colorValue = vec4(0, 0, 0, 0); ","    "," float biggest_gray_value = 0.0; "," float opacityFactor = uOpacityVal; ","  "," for(int i = 0; i < uStepsI; i++) "," {       ","     vec3 gray_val = getVolumeValue(vpos.xyz); ","     if(gray_val.z < 0.05 || ","         gray_val.x < minSos ||","         gray_val.x > maxSos ||       ","         gray_val.y < minAtten ||","         gray_val.y > maxAtten ||","         gray_val.z < minRefl ||","         gray_val.z > maxRefl ","       )  ","         colorValue = vec4(0.0);   ","   ","     else { ","            if(biggest_gray_value < gray_val.x)  ","              biggest_gray_value = gray_val.x;    ","             colorValue.g = (darkness * 2.5 - biggest_gray_value) * l * 0.15;","             sample.a = 0.1 * opacityFactor; ","             sample.b = colorValue.g * s * 2.0; ","             sample.g = colorValue.g; ","             sample.r = colorValue.g; ","             accum = sample; ","     }    ","   ","     //advance the current position ","     vpos.xyz += Step;  ","   ","   if(vpos.x > 1.0 || vpos.y > 1.0 || vpos.z > 1.0 || vpos.x < 0.0 || vpos.y < 0.0 || vpos.z < 0.0)      ","         break;  "," } "," gl_FragColor = accum; ","}"].join("\n")},function(namespace){var VolumeRaycaster=function(config){var me={};return me._needRedraw=!0,me._isStart=!1,me._isChange=!1,me._clock=new THREE.Clock,me._onLoadSlicemap=new VRC.EventDispatcher,me._onLoadSlicemaps=new VRC.EventDispatcher,me._core=new VRC.Core(config),me._adaptationManager=new VRC.AdaptationManager,me.init=function(){function animate(){if(requestAnimationFrame(animate),me._needRedraw&&(frames=10,me.isChange||(me._needRedraw=!1,counter=0)),frames>0&&me._isStart){var delta=me._clock.getDelta(),fps=1/delta;console.log("Drawing "+frames+" Counter: "+counter),me._core.draw(fps),frames--,counter++,counter>500&&(me.isChange=!1,counter=0)}}me._core.init(),me._adaptationManager.init(me._core);var frames=0;me.addCallback("onCameraChange",function(){me._needRedraw=!0,me.isChange=!0}),me.addCallback("onCameraChangeStart",function(){me._needRedraw=!0,me.isChange=!0}),me.addCallback("onCameraChangeEnd",function(){me._needRedraw=!1,me.isChange=!1});var counter=0;animate()},me.setSlicemapsImages=function(images,imagesPaths){var maxTexSize=me._core.getMaxTextureSize(),maxTexturesNumber=me._core.getMaxTexturesNumber(),firstImage=images[0],imagesNumber=images.length;if(imagesNumber>maxTexturesNumber)throw Error("Number of slicemaps bigger then number of available texture units. Available texture units: "+maxTexturesNumber);if(Math.max(firstImage.width,firstImage.height)>maxTexSize||imagesNumber>maxTexturesNumber)throw Error("Size of slice bigger than maximum possible on current GPU. Maximum size of texture: "+maxTexSize);me._core.setSlicemapsImages(images,imagesPaths),me._needRedraw=!0},me.uploadSlicemapsImages=function(imagesPaths,userOnLoadImage,userOnLoadImages,userOnError){var downloadImages=function(imagesPaths,onLoadImage,onLoadImages,onError){var downloadedImages=[],downloadedImagesNumber=0;try{for(var imageIndex=0;imageIndex<imagesPaths.length;imageIndex++){var image=new Image;!function(image,imageIndex){image.onload=function(){downloadedImages[imageIndex]=image,downloadedImagesNumber++,onLoadImage(image),downloadedImagesNumber==imagesPaths.length&&onLoadImages(downloadedImages)},image.onerror=onError,image.src=imagesPaths[imageIndex]}(image,imageIndex)}}catch(e){onError(e)}};downloadImages(imagesPaths,function(image){me._onLoadSlicemap.call(image),void 0!=userOnLoadImage&&userOnLoadImage(image)},function(images){me.setSlicemapsImages(images,imagesPaths),me._onLoadSlicemaps.call(images),void 0!=userOnLoadImages&&userOnLoadImages(images)},function(error){void 0!=userOnError?userOnError(error):console.error(error)})},me.start=function(){me._isStart=!0,console.log("VRC: start()")},me.stop=function(){me._isStart=!1,console.log("VRC: stop()")},me.setSteps=function(steps_number){if(!(steps_number<=me._core.getMaxStepsNumber()))throw Error("Number of steps should be lower of equal length of min volume dimension.");me._core.setSteps(steps_number),me._needRedraw=!0},me.setAutoStepsOn=function(flag){me._adaptationManager.run(flag),me._needRedraw=!0},me.setSlicesRange=function(from,to){me._core.setSlicesRange(from,to),me._needRedraw=!0},me.setMode=function(conf){me._core.setMode(conf),me._needRedraw=!0},me.setOpacityFactor=function(opacity_factor){me._core.setOpacityFactor(opacity_factor),me._needRedraw=!0},me.setColorFactor=function(color_factor){me._core.setColorFactor(color_factor),me._needRedraw=!0},me.setAbsorptionMode=function(mode_index){me._core.setAbsorptionMode(mode_index),me._needRedraw=!0},me.setVolumeSize=function(width,height,depth){me._core.setVolumeSize(width,height,depth),me._needRedraw=!0},me.setGeometryMinX=function(value){if(value>1||0>value)throw Error("Geometry size  should be in range [0.0 - 1.0] !");if(value>me._core.getGeometryDimensions().xmax)throw Error("Min X should be lower than max X!");var geometryDimension=me._core.getGeometryDimensions();geometryDimension.xmin=value,me._core.setGeometryDimensions(geometryDimension),me._needRedraw=!0},me.setGeometryMaxX=function(value){if(value>1||0>value)throw Error("Geometry size  should be in range [0.0 - 1.0] !");if(value<me._core.getGeometryDimensions().xmin)throw Error("Max X should be bigger than min X!");var geometryDimension=me._core.getGeometryDimensions();geometryDimension.xmax=value,me._core.setGeometryDimensions(geometryDimension),me._needRedraw=!0},me.setGeometryMinY=function(value){if(value>1||0>value)throw Error("Geometry size  should be in range [0.0 - 1.0] !");if(value>me._core.getGeometryDimensions().ymax)throw Error("Min Y should be lower than max Y!");var geometryDimension=me._core.getGeometryDimensions();geometryDimension.ymin=value,me._core.setGeometryDimensions(geometryDimension),me._needRedraw=!0},me.setGeometryMaxY=function(value){if(value>1||0>value)throw Error("Geometry size  should be in range [0.0 - 1.0] !");if(value<me._core.getGeometryDimensions().ymin)throw Error("Max Y should be bigger than min Y!");var geometryDimension=me._core.getGeometryDimensions();geometryDimension.ymax=value,me._core.setGeometryDimensions(geometryDimension),me._needRedraw=!0},me.setGeometryMinZ=function(value){if(value>1||0>value)throw Error("Geometry size  should be in range [0.0 - 1.0] !");if(value>me._core.getGeometryDimensions().zmax)throw Error("Min Z should be lower than max Z!");var geometryDimension=me._core.getGeometryDimensions();geometryDimension.zmin=value,me._core.setGeometryDimensions(geometryDimension),me._needRedraw=!0},me.setGeometryMaxZ=function(value){if(value>1||0>value)throw Error("Geometry size  should be in range [0.0 - 1.0] !");if(value<me._core.getGeometryDimensions().zmin)throw Error("Max Z should be bigger than min Z!");var geometryDimension=me._core.getGeometryDimensions();geometryDimension.zmax=value,me._core.setGeometryDimensions(geometryDimension),me._needRedraw=!0},me.setRenderCanvasSize=function(width,height){me._core.setRenderCanvasSize(width,height),me._needRedraw=!0},me.setAxis=function(){me._core.setAxis(),me._needRedraw=!0},me.setBackgroundColor=function(color){me._core.setBackgroundColor(color),me._needRedraw=!0},me.setL=function(value){me._core.setL(value),me._needRedraw=!0},me.setS=function(value){me._core.setS(value),me._needRedraw=!0},me.setHMin=function(value){me._core.setHMin(value),me._needRedraw=!0},me.setHMax=function(value){me._core.setHMax(value),me._needRedraw=!0;
},me.setMinRefl=function(value){me._core.setMinRefl(value),me._needRedraw=!0},me.setMinSos=function(value){me._core.setMinSos(value),me._needRedraw=!0},me.setMinAtten=function(value){me._core.setMinAtten(value),me._needRedraw=!0},me.setMaxRefl=function(value){me._core.setMaxRefl(value),me._needRedraw=!0},me.setMaxSos=function(value){me._core.setMaxSos(value),me._needRedraw=!0},me.setMaxAtten=function(value){me._core.setMaxAtten(value),me._needRedraw=!0},me.setRowCol=function(row,col){me._core.setRowCol(row,col),me._needRedraw=!0},me.setGrayMinValue=function(value){if(value>1||0>value)throw Error("Gray value should be in range [0.0 - 1.0] !");if(value>me.getGrayMaxValue())throw Error("Gray min value should be lower than max value!");me._core.setGrayMinValue(value),me._needRedraw=!0},me.setGrayMaxValue=function(value){if(value>1||0>value)throw Error("Gray value should be in range [0.0 - 1.0] !");if(value<me.getGrayMinValue())throw Error("Gray max value should be bigger than min value!");me._core.setGrayMaxValue(value),me._needRedraw=!0},me.Axis=function(){me._core.setAxis(),me._needRedraw=!0},me.applyThresholding=function(threshold_name){me._core.applyThresholding(threshold_name),me._needRedraw=!0},me.setTransferFunctionByColors=function(colors){me._core.setTransferFunctionByColors(colors),me._needRedraw=!0},me.setTransferFunctionByImage=function(image){me._core.setTransferFunctionByImage(image),me._needRedraw=!0},me.addCallback=function(event_name,callback,needStart){switch(event_name){case"onPreDraw":return me._core.onPreDraw.add(callback,needStart);case"onPostDraw":return me._core.onPostDraw.add(callback,needStart);case"onResizeWindow":return me._core.onResizeWindow.add(callback,needStart);case"onCameraChange":return me._core.onCameraChange.add(callback,needStart);case"onCameraChangeStart":return me._core.onCameraChangeStart.add(callback,needStart);case"onCameraChangeEnd":return me._core.onCameraChangeEnd.add(callback,needStart);case"onChangeTransferFunction":return me._core.onChangeTransferFunction.add(callback,needStart);case"onLoadSlicemap":return me._onLoadSlicemap.add(callback,needStart);case"onLoadSlicemaps":return me._onLoadSlicemaps.add(callback,needStart)}me._needRedraw=!0},me.removeCallback=function(event_name,index){switch(event_name){case"onPreDraw":return me._core.onPreDraw.remove(index);case"onPostDraw":return me._core.onPostDraw.remove(index);case"onResizeWindow":return me._core.onResizeWindow.remove(index);case"onCameraChange":return me._core.onCameraChange.remove(index);case"onCameraChangeStart":return me._core.onCameraChangeStart.remove(index);case"onCameraChangeEnd":return me._core.onCameraChangeEnd.remove(index);case"onChangeTransferFunction":return me._core.onChangeTransferFunction.remove(index);case"onLoadSlicemap":return me._onLoadSlicemap.remove(callback,needStart);case"onLoadSlicemaps":return me._onLoadSlicemaps.remove(callback,needStart)}me._needRedraw=!0},me.startCallback=function(event_name,index){switch(event_name){case"onPreDraw":return me._core.onPreDraw.start(index);case"onPostDraw":return me._core.onPostDraw.start(index);case"onResizeWindow":return me._core.onResizeWindow.start(index);case"onCameraChange":return me._core.onCameraChange.start(index);case"onCameraChangeStart":return me._core.onCameraChangeStart.start(index);case"onCameraChangeEnd":return me._core.onCameraChangeEnd.start(index);case"onChangeTransferFunction":return me._core.onChangeTransferFunction.start(index);case"onLoadSlicemap":return me._onLoadSlicemap.start(callback,needStart);case"onLoadSlicemaps":return me._onLoadSlicemaps.start(callback,needStart)}me._needRedraw=!0},me.stopCallback=function(event_name,index){switch(event_name){case"onPreDraw":return me._core.onPreDraw.stop(index);case"onPostDraw":return me._core.onPostDraw.stop(index);case"onResizeWindow":return me._core.onResizeWindow.stop(index);case"onCameraChange":return me._core.onCameraChange.stop(index);case"onCameraChangeStart":return me._core.onCameraChangeStart.stop(index);case"onCameraChangeEnd":return me._core.onCameraChangeEnd.stop(index);case"onChangeTransferFunction":return me._core.onChangeTransferFunction.stop(index);case"onLoadSlicemap":return me._onLoadSlicemap.stop(callback,needStart);case"onLoadSlicemaps":return me._onLoadSlicemaps.stop(callback,needStart)}me._needRedraw=!0},me.isStartCallback=function(event_name,index){switch(event_name){case"onPreDraw":return me._core.onPreDraw.isStart(index);case"onPostDraw":return me._core.onPostDraw.isStart(index);case"onResizeWindow":return me._core.onResizeWindow.isStart(index);case"onCameraChange":return me._core.onCameraChange.isStart(index);case"onCameraChangeStart":return me._core.onCameraChangeStart.isStart(index);case"onCameraChangeEnd":return me._core.onCameraChangeEnd.isStart(index);case"onChangeTransferFunction":return me._core.onChangeTransferFunction.isStart(index);case"onLoadSlicemap":return me._onLoadSlicemap.isStart(callback,needStart);case"onLoadSlicemaps":return me._onLoadSlicemaps.isStart(callback,needStart)}me._needRedraw=!0},me.getGrayMaxValue=function(){return me._core.getGrayMaxValue()},me.getGrayMinValue=function(){return me._core.getGrayMinValue()},me.getSteps=function(){return me._core.getSteps()},me.getSlicesRange=function(){return me._core.getSlicesRange()},me.getRowCol=function(){return me._core.getRowCol()},me.getGrayValue=function(){return[me._core.getGrayMinValue(),me._core.getGrayMaxValue()]},me.getGeometryDimensions=function(){return me._core.getGeometryDimensions()},me.getVolumeSize=function(){return me._core.getVolumeSize()},me.getVolumeSizeNormalized=function(){return me._core.getVolumeSizeNormalized()},me.getMaxStepsNumber=function(){return me._core.getMaxStepsNumber()},me.getMaxTextureSize=function(){return me._core.getMaxTextureSize()},me.getMaxTexturesNumber=function(){return me._core.getMaxTexturesNumber()},me.getMaxFramebuferSize=function(){return me._core.getMaxFramebuferSize()},me.getOpacityFactor=function(){return me._core.getOpacityFactor()},me.getColorFactor=function(){return me._core.getColorFactor()},me.getBackground=function(){return me._core.getBackground()},me.getAbsorptionMode=function(){return me._core.getAbsorptionMode()},me.getRenderSize=function(){return me._core.getRenderSize()},me.getRenderSizeInPixels=function(){return me._core.getRenderSizeInPixels()},me.getRenderCanvasSize=function(){return me._core.getCanvasSize()},me.getRenderCavnvasSizeInPixels=function(){return me._core.getCanvasSizeInPixels()},me.getAbsorptionMode=function(){return me._core.getAbsorptionMode()},me.getSlicemapsPaths=function(){return me._core.getSlicemapsPaths()},me.getDomContainerId=function(){return me._core.getDomContainerId()},me.getCameraSettings=function(){return me._core.getCameraSettings()},me.getGeometrySettings=function(){return me._core.getGeometrySettings()},me.getDomContainerId=function(){return me._core.getDomContainerId()},me.getClearColor=function(){return me._core.getClearColor()},me.getTransferFunctionColors=function(){return me._core.getTransferFunctionColors()},me.getTransferFunctionAsImage=function(){return me._core.getTransferFunctionAsImage()},me.isAutoStepsOn=function(){return console.log("Check"),console.log(me._adaptationManager.isRun()),me._adaptationManager.isRun()},me.setAxis=function(){return me._core.setAxis()},me.draw=function(){me._core.draw()},me.setConfig=function(config,onLoadImage,onLoadImages){void 0!=config.slicemaps_images&&me.setSlicemapsImages(config.slicemaps_images),void 0!=config.slicemaps_paths&&me.uploadSlicemapsImages(config.slicemaps_paths,function(image){void 0!=onLoadImage&&onLoadImage(image)},function(images){void 0!=config.slices_range&&me.setSlicesRange(config.slices_range[0],config.slices_range[1]),void 0!=onLoadImages&&onLoadImages(images),me.start()}),void 0!=config.slices_range&&me.setSlicesRange(config.slices_range[0],config.slices_range[1]),void 0!=config.steps&&me._core.setSteps(config.steps),void 0!=config.row_col&&me._core.setRowCol(config.row_col[0],config.row_col[1]),void 0!=config.test&&me._core.setRowCol(config.test,config.test),void 0!=config.gray_min&&me._core.setGrayMinValue(config.gray_min),void 0!=config.gray_max&&me._core.setGrayMaxValue(config.gray_max),void 0!=config.threshold_indexes&&me._core.setThresholdIndexes(config.threshold_indexes.otsu,config.threshold_indexes.isodata,config.threshold_indexes.yen,config.threshold_indexes.li),void 0!=config.volume_size&&me.setVolumeSize(config.volume_size[0],config.volume_size[1],config.volume_size[2]),void 0!=config.x_min&&me.setGeometryMinX(config.x_min),void 0!=config.x_max&&me.setGeometryMaxX(config.x_max),void 0!=config.y_min&&me.setGeometryMinY(config.y_min),void 0!=config.y_max&&me.setGeometryMaxY(config.y_max),void 0!=config.z_min&&me.setGeometryMinZ(config.z_min),void 0!=config.z_max&&me.setGeometryMaxZ(config.z_max),void 0!=config.opacity_factor&&me._core.setOpacityFactor(config.opacity_factor),void 0!=config.color_factor&&me._core.setColorFactor(config.color_factor),void 0!=config.tf_colors&&me._core.setTransferFunctionByColors(config.tf_colors),void 0!=config.background&&me._core.setBackgroundColor(config.background),void 0!=config.auto_steps&&me.setAutoStepsOn(config.auto_steps),void 0!=config.axis&&me.setAxis(config.axis),void 0!=config.absorption_mode&&me._core.setAbsorptionMode(config.absorption_mode),void 0!=config.render_canvas_size&&me.setRenderCanvasSize(config.render_canvas_size[0],config.render_canvas_size[1]),me._needRedraw=!0},me.uploadConfig=function(path,onLoad,onError){var xmlhttp;xmlhttp=window.XMLHttpRequest?new XMLHttpRequest:new ActiveXObject("Microsoft.XMLHTTP"),xmlhttp.onreadystatechange=function(){if(xmlhttp.readyState==XMLHttpRequest.DONE)if(200==xmlhttp.status){var config=JSON.parse(xmlhttp.responseText);me.setConfig(config),void 0!=onLoad&&onLoad()}else 400==xmlhttp.status?void 0!=userOnError&&userOnError(xmlhttp):void 0!=userOnError&&userOnError(xmlhttp)},xmlhttp.open("GET",path,!0),xmlhttp.send()},me.getConfig=function(){var config={steps:me.getSteps(),slices_range:me.getSlicesRange(),volume_size:me.getVolumeSize(),row_col:me.getRowCol(),gray_min:me.getGrayMinValue(),gray_max:me.getGrayMaxValue(),slicemaps_paths:me.getSlicemapsPaths(),opacity_factor:me.getOpacityFactor(),color_factor:me.getColorFactor(),absorption_mode:me.getAbsorptionMode(),render_size:me.getRenderSize(),render_canvas_size:me.getRenderCanvasSize(),backgound:me.getClearColor(),tf_path:me.getTransferFunctionAsImage().src,tf_colors:me.getTransferFunctionColors(),x_min:me.getGeometryDimensions().xmin,x_max:me.getGeometryDimensions().xmax,y_min:me.getGeometryDimensions().ymin,y_max:me.getGeometryDimensions().ymax,z_min:me.getGeometryDimensions().zmin,z_max:me.getGeometryDimensions().zmax,dom_container_id:me.getDomContainerId(),auto_steps:me.isAutoStepsOn(),axis:!0};return config},me.init(),me.setConfig(config),me};namespace.VolumeRaycaster=VolumeRaycaster}(window.VRC);